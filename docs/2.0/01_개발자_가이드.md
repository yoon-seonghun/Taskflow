# TaskFlow 2.0 개발자 가이드

## 목차

1. [프로젝트 개요](#1-프로젝트-개요)
2. [기술 스택](#2-기술-스택)
3. [시스템 아키텍처](#3-시스템-아키텍처)
4. [디렉토리 구조](#4-디렉토리-구조)
5. [데이터베이스 설계](#5-데이터베이스-설계)
6. [백엔드 개발 가이드](#6-백엔드-개발-가이드)
7. [프론트엔드 개발 가이드](#7-프론트엔드-개발-가이드)
8. [인증 및 보안](#8-인증-및-보안)
9. [실시간 동기화 (SSE)](#9-실시간-동기화-sse)
10. [개발 환경 설정](#10-개발-환경-설정)
11. [빌드 및 배포](#11-빌드-및-배포)
12. [코딩 컨벤션](#12-코딩-컨벤션)
13. [트러블슈팅](#13-트러블슈팅)

---

## 1. 프로젝트 개요

### 1.1 TaskFlow 소개

TaskFlow는 Notion 스타일의 업무 관리 시스템으로, 팀 구성원 간 업무 현황을 실시간으로 공유하고 협업할 수 있는 웹 애플리케이션입니다.

### 1.2 핵심 특징

| 특징 | 설명 |
|------|------|
| **Compact/Dense UI** | Notion 스타일의 밀도 높은 UI (Row Height 36px 이하) |
| **동적 속성 시스템** | EAV(Entity-Attribute-Value) 패턴 기반 유연한 속성 관리 |
| **다중 뷰 지원** | 테이블, 칸반, 리스트 뷰 전환 |
| **인라인 편집** | 모든 속성 클릭 시 즉시 편집 |
| **실시간 동기화** | SSE(Server-Sent Events) 기반 실시간 업데이트 |
| **반응형 디자인** | 모바일/PC 최적화 |

### 1.3 버전 정보

- **현재 버전**: 2.0.0
- **최종 업데이트**: 2024년 12월
- **호환성**: Java 17+, Node.js 18+, MySQL 8.0+

---

## 2. 기술 스택

### 2.1 전체 스택 구성

```
┌─────────────────────────────────────────────────────────────┐
│                        Frontend                              │
│  Vue 3 + TypeScript + Vite + Tailwind CSS + Pinia           │
├─────────────────────────────────────────────────────────────┤
│                        Backend                               │
│  Spring Boot 3.x + MyBatis + MySQL                          │
├─────────────────────────────────────────────────────────────┤
│                      Infrastructure                          │
│  Docker + Nginx + MySQL 8.0                                 │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 상세 기술 스택

#### Backend

| 구분 | 기술 | 버전 | 용도 |
|------|------|------|------|
| Framework | Spring Boot | 3.x | 애플리케이션 프레임워크 |
| Language | Java | 17+ | 백엔드 언어 |
| ORM | MyBatis | 3.5.x | SQL Mapper (JPA 사용 금지) |
| Database | MySQL | 8.0+ | 관계형 데이터베이스 |
| Security | Spring Security | 6.x | 인증/인가 |
| JWT | jjwt | 0.11.x | 토큰 기반 인증 |

#### Frontend

| 구분 | 기술 | 버전 | 용도 |
|------|------|------|------|
| Framework | Vue.js | 3.x | UI 프레임워크 |
| Language | TypeScript | 5.x | 타입 안전성 |
| Build Tool | Vite | 5.x | 빌드 및 개발 서버 |
| CSS | Tailwind CSS | 3.x | 유틸리티 CSS |
| State | Pinia | 2.x | 상태 관리 |
| HTTP Client | Axios | 1.x | API 통신 |

#### Infrastructure

| 구분 | 기술 | 용도 |
|------|------|------|
| Container | Docker | 컨테이너화 |
| Orchestration | Docker Compose | 멀티 컨테이너 관리 |
| Web Server | Nginx | 리버스 프록시, 정적 파일 서빙 |
| Database | MySQL 8.0 | 데이터 저장소 |

---

## 3. 시스템 아키텍처

### 3.1 전체 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              Client                                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                      │
│  │   Browser   │  │   Mobile    │  │   Tablet    │                      │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘                      │
│         │                │                │                              │
│         └────────────────┴────────────────┘                              │
│                          │                                               │
│                     HTTPS/WSS                                            │
└─────────────────────────────────────────────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                           Docker Network                                 │
│                                                                         │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │                        Nginx (Port 80)                            │  │
│  │  - Static File Serving (Vue Build)                                │  │
│  │  - Reverse Proxy → /api/* → backend:8080                         │  │
│  │  - Gzip Compression                                               │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                │                                        │
│              ┌─────────────────┴─────────────────┐                     │
│              │                                   │                      │
│              ▼                                   ▼                      │
│  ┌────────────────────────┐      ┌────────────────────────┐           │
│  │   Frontend Container   │      │   Backend Container    │           │
│  │   (Nginx + Vue Build)  │      │   (Spring Boot:8080)   │           │
│  │                        │      │                        │           │
│  │   - Vue 3 + Vite       │      │   - REST API           │           │
│  │   - Tailwind CSS       │      │   - SSE Endpoint       │           │
│  │   - Pinia Store        │      │   - JWT Auth           │           │
│  └────────────────────────┘      └───────────┬────────────┘           │
│                                              │                         │
│                                              ▼                         │
│                              ┌────────────────────────┐                │
│                              │   MySQL Container      │                │
│                              │   (Port 3306)          │                │
│                              │                        │                │
│                              │   - taskflow DB        │                │
│                              │   - UTF8MB4            │                │
│                              └────────────────────────┘                │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 3.2 레이어 아키텍처 (Backend)

```
┌─────────────────────────────────────────────────────────────┐
│                      Presentation Layer                      │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    Controllers                       │   │
│  │  - REST API Endpoints                               │   │
│  │  - Request/Response DTO Handling                    │   │
│  │  - Validation                                       │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                       Business Layer                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                     Services                         │   │
│  │  - Business Logic                                   │   │
│  │  - Transaction Management                           │   │
│  │  - Service Composition                              │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                     Persistence Layer                        │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                     Mappers                          │   │
│  │  - MyBatis XML Mappers                              │   │
│  │  - SQL Query Definitions                            │   │
│  │  - Result Mappings                                  │   │
│  └─────────────────────────────────────────────────────┘   │
├─────────────────────────────────────────────────────────────┤
│                       Domain Layer                           │
│  ┌─────────────────────────────────────────────────────┐   │
│  │                    Entities                          │   │
│  │  - Domain Objects                                   │   │
│  │  - DTOs (Request/Response)                          │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 3.3 데이터 흐름

```
Request Flow:
┌────────┐    ┌────────────┐    ┌─────────┐    ┌────────┐    ┌───────┐
│ Client │───▶│ Controller │───▶│ Service │───▶│ Mapper │───▶│ MySQL │
└────────┘    └────────────┘    └─────────┘    └────────┘    └───────┘
    │              │                 │              │             │
    │         Validation         Business       SQL Query      Data
    │         DTO Mapping         Logic         Execution      Store

Response Flow:
┌───────┐    ┌────────┐    ┌─────────┐    ┌────────────┐    ┌────────┐
│ MySQL │───▶│ Mapper │───▶│ Service │───▶│ Controller │───▶│ Client │
└───────┘    └────────┘    └─────────┘    └────────────┘    └────────┘
    │            │              │               │                │
   Data      Result Map     Transform      ApiResponse       JSON
             to Entity      to DTO           Wrap           Response
```

---

## 4. 디렉토리 구조

### 4.1 프로젝트 루트 구조

```
Taskflow/
├── backend/                    # Spring Boot 백엔드
├── frontend/                   # Vue.js 프론트엔드
├── docker/                     # Docker 관련 설정
│   └── mysql/
│       └── init/
│           └── 01_schema.sql   # DB 스키마 초기화
├── docs/                       # 문서
│   └── 2.0/                    # 버전 2.0 문서
├── docker-compose.yml          # Docker Compose 설정
├── .env.example                # 환경변수 예시
├── build-release.sh            # Linux/Mac 배포 스크립트
├── build-release.ps1           # Windows 배포 스크립트
└── CLAUDE.md                   # 프로젝트 명세서
```

### 4.2 Backend 구조

```
backend/
├── src/main/java/com/taskflow/
│   ├── TaskflowApplication.java       # 메인 애플리케이션
│   ├── config/                        # 설정 클래스
│   │   ├── MyBatisConfig.java         # MyBatis 설정
│   │   ├── AsyncConfig.java           # 비동기 처리 설정
│   │   └── SecurityConfig.java        # Spring Security 설정
│   ├── controller/                    # REST 컨트롤러
│   │   ├── AuthController.java        # 인증 API
│   │   ├── UserController.java        # 사용자 API
│   │   ├── DepartmentController.java  # 부서 API
│   │   ├── GroupController.java       # 그룹 API
│   │   ├── BoardController.java       # 보드 API
│   │   ├── ItemController.java        # 업무 API
│   │   ├── CommentController.java     # 댓글 API
│   │   ├── PropertyController.java    # 속성 API
│   │   ├── OptionController.java      # 옵션 API
│   │   ├── TaskTemplateController.java # 템플릿 API
│   │   ├── HistoryController.java     # 이력 API
│   │   ├── FileController.java        # 파일 API
│   │   ├── SseController.java         # SSE API
│   │   └── HealthController.java      # 헬스체크 API
│   ├── service/                       # 비즈니스 로직
│   │   ├── AuthService.java
│   │   ├── UserService.java
│   │   ├── DepartmentService.java
│   │   ├── BoardService.java
│   │   ├── ItemService.java
│   │   ├── PropertyService.java
│   │   ├── PropertyCacheService.java  # 속성 캐시
│   │   └── impl/                      # 구현 클래스
│   ├── mapper/                        # MyBatis Mapper 인터페이스
│   │   ├── UserMapper.java
│   │   ├── DepartmentMapper.java
│   │   ├── BoardMapper.java
│   │   ├── ItemMapper.java
│   │   └── ...
│   ├── domain/                        # 도메인 엔티티
│   │   ├── User.java
│   │   ├── Department.java
│   │   ├── Board.java
│   │   ├── Item.java
│   │   ├── PropertyDef.java
│   │   ├── PropertyOption.java
│   │   └── ...
│   ├── dto/                           # 데이터 전송 객체
│   │   ├── auth/
│   │   │   ├── LoginRequest.java
│   │   │   └── LoginResponse.java
│   │   ├── user/
│   │   ├── board/
│   │   ├── item/
│   │   └── ...
│   ├── security/                      # 보안 관련
│   │   ├── JwtAuthenticationFilter.java
│   │   ├── JwtAuthenticationEntryPoint.java
│   │   ├── UserPrincipal.java
│   │   └── SecurityUtils.java
│   ├── sse/                           # SSE 관련
│   │   ├── SseEmitterManager.java
│   │   └── SseEventPublisher.java
│   ├── common/                        # 공통 클래스
│   │   ├── ApiResponse.java
│   │   ├── PageRequest.java
│   │   └── PageResponse.java
│   └── exception/                     # 예외 처리
│       ├── BusinessException.java
│       └── GlobalExceptionHandler.java
│
├── src/main/resources/
│   ├── application.yml                # 애플리케이션 설정
│   └── mapper/                        # MyBatis XML Mapper
│       ├── UserMapper.xml
│       ├── DepartmentMapper.xml
│       ├── BoardMapper.xml
│       ├── ItemMapper.xml
│       ├── PropertyDefMapper.xml
│       ├── PropertyOptionMapper.xml
│       └── ...
│
├── build.gradle.kts                   # Gradle 빌드 설정
├── settings.gradle.kts                # Gradle 프로젝트 설정
├── Dockerfile                         # Docker 이미지 빌드
├── gradlew                            # Gradle Wrapper (Linux/Mac)
└── gradlew.bat                        # Gradle Wrapper (Windows)
```

### 4.3 Frontend 구조

```
frontend/
├── src/
│   ├── api/                           # API 통신 모듈
│   │   ├── client.ts                  # Axios 클라이언트 설정
│   │   ├── auth.ts                    # 인증 API
│   │   ├── user.ts                    # 사용자 API
│   │   ├── department.ts              # 부서 API
│   │   ├── group.ts                   # 그룹 API
│   │   ├── board.ts                   # 보드 API
│   │   ├── item.ts                    # 업무 API
│   │   ├── comment.ts                 # 댓글 API
│   │   ├── property.ts                # 속성 API
│   │   ├── share.ts                   # 공유 API
│   │   ├── file.ts                    # 파일 API
│   │   ├── history.ts                 # 이력 API
│   │   └── taskTemplate.ts            # 템플릿 API
│   │
│   ├── components/                    # 컴포넌트
│   │   ├── common/                    # 공통 컴포넌트
│   │   │   ├── Button.vue
│   │   │   ├── Input.vue
│   │   │   ├── Select.vue
│   │   │   ├── Modal.vue
│   │   │   ├── Toast.vue
│   │   │   ├── Spinner.vue
│   │   │   ├── Pagination.vue
│   │   │   ├── DatePicker.vue
│   │   │   ├── ContextMenu.vue
│   │   │   ├── ConfirmDialog.vue
│   │   │   ├── InlineEditor.vue
│   │   │   ├── MarkdownEditor.vue
│   │   │   ├── UserSelect.vue
│   │   │   ├── UserSearchSelector.vue
│   │   │   ├── DepartmentTree.vue
│   │   │   └── ErrorBoundary.vue
│   │   ├── layout/                    # 레이아웃
│   │   │   ├── MainLayout.vue
│   │   │   ├── Header.vue
│   │   │   └── Sidebar.vue
│   │   ├── item/                      # 업무 관련
│   │   │   ├── ItemTable.vue
│   │   │   ├── ItemKanban.vue
│   │   │   ├── ItemList.vue
│   │   │   ├── ItemCard.vue
│   │   │   ├── ItemRow.vue
│   │   │   ├── ItemForm.vue
│   │   │   ├── ItemDetail.vue
│   │   │   ├── ItemDetailPanel.vue
│   │   │   ├── ItemShareModal.vue
│   │   │   ├── ItemTransferModal.vue
│   │   │   ├── NewItemInput.vue
│   │   │   ├── KanbanColumn.vue
│   │   │   └── CompletedItemsCollapse.vue
│   │   ├── property/                  # 속성 관련
│   │   │   ├── PropertyEditor.vue
│   │   │   ├── PropertyHeader.vue
│   │   │   ├── PropertyHeaderMenu.vue
│   │   │   ├── PropertyTypeSelector.vue
│   │   │   └── OptionManager.vue
│   │   ├── comment/                   # 댓글
│   │   │   ├── CommentList.vue
│   │   │   └── CommentInput.vue
│   │   ├── share/                     # 공유
│   │   │   ├── ShareUserList.vue
│   │   │   └── ShareUserSearch.vue
│   │   ├── board/                     # 보드
│   │   │   └── BoardTransferModal.vue
│   │   ├── department/                # 부서
│   │   │   ├── DepartmentTree.vue
│   │   │   ├── DepartmentNode.vue
│   │   │   └── DepartmentForm.vue
│   │   ├── group/                     # 그룹
│   │   │   ├── GroupList.vue
│   │   │   ├── GroupForm.vue
│   │   │   └── GroupMemberManager.vue
│   │   ├── user/                      # 사용자
│   │   │   ├── UserList.vue
│   │   │   └── UserForm.vue
│   │   ├── template/                  # 템플릿
│   │   │   ├── TemplateList.vue
│   │   │   └── TemplateForm.vue
│   │   ├── history/                   # 이력
│   │   │   ├── HistoryTable.vue
│   │   │   └── HistorySwitch.vue
│   │   ├── file/                      # 파일
│   │   │   ├── FileAttachment.vue
│   │   │   ├── FileList.vue
│   │   │   └── FileListItem.vue
│   │   └── ui/                        # UI 컴포넌트
│   │       └── SlideOverPanel.vue
│   │
│   ├── views/                         # 페이지 컴포넌트
│   │   ├── LoginView.vue              # 로그인
│   │   ├── TasksView.vue              # 업무 페이지 (메인)
│   │   ├── BoardsView.vue             # 보드 관리
│   │   ├── CompletedView.vue          # 완료 업무
│   │   ├── DeletedTasksView.vue       # 삭제 업무
│   │   ├── OverdueView.vue            # 기한 초과
│   │   ├── PendingView.vue            # 미처리 업무
│   │   ├── SharesView.vue             # 공유 보드
│   │   ├── ShareUsersView.vue         # 공유 사용자
│   │   ├── HistoryView.vue            # 이력 관리
│   │   ├── TemplatesView.vue          # 템플릿 관리
│   │   ├── UsersView.vue              # 사용자 관리
│   │   ├── DepartmentsView.vue        # 부서 관리
│   │   ├── GroupsView.vue             # 그룹 관리
│   │   ├── SettingsView.vue           # 설정
│   │   ├── ItemDetailView.vue         # 업무 상세 (모바일)
│   │   └── NotFoundView.vue           # 404 페이지
│   │
│   ├── stores/                        # Pinia 스토어
│   │   ├── auth.ts                    # 인증 상태
│   │   ├── board.ts                   # 보드 상태
│   │   ├── item.ts                    # 업무 상태
│   │   ├── property.ts                # 속성 상태
│   │   ├── department.ts              # 부서 상태
│   │   ├── group.ts                   # 그룹 상태
│   │   ├── sse.ts                     # SSE 상태
│   │   └── ui.ts                      # UI 상태
│   │
│   ├── composables/                   # Composition API 훅
│   │   ├── useAuth.ts                 # 인증 훅
│   │   ├── useConfirm.ts              # 확인 다이얼로그
│   │   ├── useDebounce.ts             # 디바운스
│   │   ├── useErrorHandler.ts         # 에러 처리
│   │   ├── useLoading.ts              # 로딩 상태
│   │   ├── useSlideOver.ts            # 슬라이드오버 패널
│   │   ├── useSse.ts                  # SSE 훅
│   │   └── useToast.ts                # 토스트 알림
│   │
│   ├── types/                         # TypeScript 타입 정의
│   │   ├── api.ts                     # API 응답 타입
│   │   ├── user.ts                    # 사용자 타입
│   │   ├── board.ts                   # 보드 타입
│   │   ├── item.ts                    # 업무 타입
│   │   ├── property.ts                # 속성 타입
│   │   ├── comment.ts                 # 댓글 타입
│   │   ├── department.ts              # 부서 타입
│   │   ├── group.ts                   # 그룹 타입
│   │   ├── share.ts                   # 공유 타입
│   │   ├── file.ts                    # 파일 타입
│   │   ├── history.ts                 # 이력 타입
│   │   ├── sse.ts                     # SSE 타입
│   │   └── taskTemplate.ts            # 템플릿 타입
│   │
│   ├── router/                        # Vue Router
│   │   ├── index.ts                   # 라우터 설정
│   │   └── guards.ts                  # 라우터 가드
│   │
│   ├── utils/                         # 유틸리티
│   │   ├── index.ts
│   │   ├── item.ts                    # 업무 관련 유틸
│   │   └── errorTypes.ts              # 에러 타입
│   │
│   ├── plugins/                       # 플러그인
│   │   └── pinia.ts                   # Pinia 설정
│   │
│   ├── assets/                        # 정적 파일
│   ├── App.vue                        # 루트 컴포넌트
│   └── main.ts                        # 엔트리 포인트
│
├── public/                            # 정적 파일 (빌드 시 복사)
├── index.html                         # HTML 템플릿
├── package.json                       # NPM 설정
├── vite.config.ts                     # Vite 설정
├── tsconfig.json                      # TypeScript 설정
├── tailwind.config.js                 # Tailwind CSS 설정
├── postcss.config.js                  # PostCSS 설정
├── nginx.conf                         # Nginx 설정
└── Dockerfile                         # Docker 이미지 빌드
```

---

## 5. 데이터베이스 설계

### 5.1 ERD (Entity Relationship Diagram)

```
┌─────────────────┐       ┌─────────────────┐
│  TB_DEPARTMENT  │◄──────│    TB_USER      │
│─────────────────│  1:N  │─────────────────│
│ DEPARTMENT_ID   │       │ USER_ID         │
│ DEPARTMENT_CODE │       │ USERNAME        │
│ DEPARTMENT_NAME │       │ PASSWORD        │
│ PARENT_ID       │───┐   │ NAME            │
│ SORT_ORDER      │   │   │ EMAIL           │
│ USE_YN          │   │   │ DEPARTMENT_ID   │
└─────────────────┘   │   │ USE_YN          │
        │             │   └─────────────────┘
        └─────────────┘          │
        (자기 참조)               │
                                 │
┌─────────────────┐              │
│    TB_GROUP     │◄─────────────┤
│─────────────────│     N:M      │
│ GROUP_ID        │    ┌─────────┴─────────┐
│ GROUP_CODE      │    │  TB_USER_GROUP    │
│ GROUP_NAME      │    │───────────────────│
│ DESCRIPTION     │    │ USER_GROUP_ID     │
│ GROUP_COLOR     │    │ USER_ID           │
│ SORT_ORDER      │    │ GROUP_ID          │
│ USE_YN          │◄───┘                   │
└─────────────────┘                        │
                                           │
┌─────────────────┐                        │
│    TB_BOARD     │◄───────────────────────┤
│─────────────────│     1:1 (Owner)        │
│ BOARD_ID        │                        │
│ BOARD_NAME      │    ┌─────────────────┐ │
│ DESCRIPTION     │    │ TB_BOARD_SHARE  │ │
│ OWNER_ID        │◄───│─────────────────│◄┘
│ DEFAULT_VIEW    │ 1:N│ BOARD_SHARE_ID  │   (공유)
│ COLOR           │    │ BOARD_ID        │
│ SORT_ORDER      │    │ USER_ID         │
│ USE_YN          │    │ PERMISSION      │
└─────────────────┘    └─────────────────┘
        │
        │ 1:N
        ▼
┌─────────────────┐     ┌─────────────────┐
│ TB_PROPERTY_DEF │────▶│TB_PROPERTY_OPTION│
│─────────────────│ 1:N │─────────────────│
│ PROPERTY_ID     │     │ OPTION_ID       │
│ BOARD_ID        │     │ PROPERTY_ID     │
│ PROPERTY_NAME   │     │ OPTION_LABEL    │
│ PROPERTY_TYPE   │     │ COLOR           │
│ REQUIRED_YN     │     │ SORT_ORDER      │
│ VISIBLE_YN      │     │ USE_YN          │
│ SORT_ORDER      │     └─────────────────┘
└─────────────────┘
        │
        │ 1:N
        ▼
┌─────────────────┐     ┌─────────────────┐
│     TB_ITEM     │────▶│ TB_ITEM_PROPERTY│
│─────────────────│ 1:N │─────────────────│
│ ITEM_ID         │     │ ITEM_PROPERTY_ID│
│ BOARD_ID        │     │ ITEM_ID         │
│ CONTENT         │     │ PROPERTY_ID     │
│ DESCRIPTION     │     │ VALUE_TEXT      │
│ STATUS          │     │ VALUE_NUMBER    │
│ PRIORITY        │     │ VALUE_DATE      │
│ CATEGORY_ID     │     │ VALUE_OPTION_ID │
│ GROUP_ID        │     │ VALUE_USER_ID   │
│ ASSIGNEE_ID     │     │ VALUE_CHECKBOX  │
│ START_TIME      │     └─────────────────┘
│ END_TIME        │
│ TRANSFERRED_FROM│     ┌─────────────────────┐
│ TRANSFERRED_AT  │     │TB_ITEM_PROPERTY_MULTI│
└─────────────────┘────▶│─────────────────────│
        │           1:N │ ITEM_PROPERTY_MULTI_ID│
        │               │ ITEM_ID             │
        │               │ PROPERTY_ID         │
        │ 1:N           │ OPTION_ID           │
        ▼               └─────────────────────┘
┌─────────────────┐
│   TB_COMMENT    │
│─────────────────│
│ COMMENT_ID      │
│ ITEM_ID         │
│ CONTENT         │
└─────────────────┘

┌─────────────────┐     ┌─────────────────┐
│ TB_ITEM_SHARE   │     │ TB_TASK_TEMPLATE│
│─────────────────│     │─────────────────│
│ ITEM_SHARE_ID   │     │ TEMPLATE_ID     │
│ ITEM_ID         │     │ CONTENT         │
│ USER_ID         │     │ DEFAULT_ASSIGNEE│
│ PERMISSION      │     │ DEFAULT_STATUS  │
└─────────────────┘     │ USE_COUNT       │
                        │ USE_YN          │
┌─────────────────┐     └─────────────────┘
│  TB_AUDIT_LOG   │
│─────────────────│     ┌─────────────────┐
│ LOG_ID          │     │     TB_FILE     │
│ TARGET_TYPE     │     │─────────────────│
│ TARGET_ID       │     │ FILE_ID         │
│ ACTION          │     │ ORIGINAL_NAME   │
│ ACTOR_ID        │     │ STORED_NAME     │
│ DESCRIPTION     │     │ EXTENSION       │
│ BEFORE_DATA     │     │ MIME_TYPE       │
│ AFTER_DATA      │     │ FILE_SIZE       │
│ RELATED_USER_ID │     │ STORAGE_TYPE    │
└─────────────────┘     │ STORAGE_PATH    │
                        │ RELATED_TYPE    │
                        │ RELATED_ID      │
                        └─────────────────┘
```

### 5.2 테이블 목록

| No | 테이블명 | 설명 | 비고 |
|----|----------|------|------|
| 1 | TB_DEPARTMENT | 부서 | 계층 구조 (자기 참조) |
| 2 | TB_USER | 사용자 | 1:1 부서 연결 |
| 3 | TB_GROUP | 그룹 | 프로젝트/TF |
| 4 | TB_USER_GROUP | 사용자-그룹 매핑 | N:M 관계 |
| 5 | TB_BOARD | 보드 | 업무 컬렉션 |
| 6 | TB_BOARD_SHARE | 보드 공유 | VIEW/EDIT/FULL 권한 |
| 7 | TB_PROPERTY_DEF | 속성 정의 | EAV 패턴 |
| 8 | TB_PROPERTY_OPTION | 속성 옵션 | SELECT/MULTI_SELECT 값 |
| 9 | TB_ITEM | 업무 아이템 | 핵심 테이블 |
| 10 | TB_ITEM_PROPERTY | 아이템 속성값 | 단일 값 |
| 11 | TB_ITEM_PROPERTY_MULTI | 다중선택 속성값 | MULTI_SELECT 값 |
| 12 | TB_COMMENT | 댓글 | 업무 댓글 |
| 13 | TB_ITEM_SHARE | 업무 공유 | 개별 업무 공유 |
| 14 | TB_TASK_TEMPLATE | 작업 템플릿 | 자주 쓰는 업무 |
| 15 | TB_AUDIT_LOG | 감사 로그 | 변경 이력 |
| 16 | TB_FILE | 파일 메타데이터 | 첨부 파일 |

### 5.3 공통 컬럼

모든 테이블에 적용되는 공통 컬럼:

```sql
CREATED_AT DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성일시',
CREATED_BY BIGINT NOT NULL COMMENT '생성자',
UPDATED_AT DATETIME NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '수정일시',
UPDATED_BY BIGINT NULL COMMENT '수정자'
```

### 5.4 EAV (Entity-Attribute-Value) 패턴

동적 속성 시스템을 위한 EAV 패턴 구현:

```
TB_PROPERTY_DEF (속성 정의)
├── PROPERTY_ID: 속성 ID
├── BOARD_ID: 보드 ID (속성이 속한 보드)
├── PROPERTY_NAME: 속성 이름
├── PROPERTY_TYPE: TEXT, NUMBER, DATE, SELECT, MULTI_SELECT, CHECKBOX, USER
├── REQUIRED_YN: 필수 여부
├── VISIBLE_YN: 표시 여부
└── SORT_ORDER: 정렬 순서

TB_PROPERTY_OPTION (옵션 - SELECT/MULTI_SELECT용)
├── OPTION_ID: 옵션 ID
├── PROPERTY_ID: 속성 ID
├── OPTION_LABEL: 옵션 라벨
├── COLOR: 색상 (#RRGGBB)
└── SORT_ORDER: 정렬 순서

TB_ITEM_PROPERTY (속성값 저장)
├── VALUE_TEXT: TEXT 타입 값
├── VALUE_NUMBER: NUMBER 타입 값
├── VALUE_DATE: DATE 타입 값
├── VALUE_OPTION_ID: SELECT 타입 값 (FK)
├── VALUE_USER_ID: USER 타입 값 (FK)
└── VALUE_CHECKBOX: CHECKBOX 타입 값 (Y/N)

TB_ITEM_PROPERTY_MULTI (다중선택값)
├── ITEM_ID
├── PROPERTY_ID
└── OPTION_ID (여러 행으로 다중 값 저장)
```

---

## 6. 백엔드 개발 가이드

### 6.1 패키지 구조 규칙

```
com.taskflow
├── config/           # @Configuration 클래스
├── controller/       # @RestController 클래스
├── service/          # @Service 인터페이스
│   └── impl/         # @Service 구현 클래스
├── mapper/           # @Mapper 인터페이스
├── dto/              # Request/Response DTO
│   ├── auth/
│   ├── user/
│   ├── board/
│   └── ...
├── domain/           # Entity 클래스
├── security/         # 보안 관련 클래스
├── sse/              # SSE 관련 클래스
├── common/           # 공통 유틸리티
└── exception/        # 예외 클래스
```

### 6.2 Controller 작성 규칙

```java
@RestController
@RequestMapping("/api/boards/{boardId}/items")
@RequiredArgsConstructor
public class ItemController {

    private final ItemService itemService;

    /**
     * 아이템 목록 조회
     */
    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<ItemResponse>>> getItems(
            @PathVariable Long boardId,
            @ModelAttribute ItemSearchRequest request,
            @CurrentUser UserPrincipal currentUser) {

        PageResponse<ItemResponse> result = itemService.getItems(boardId, request, currentUser.getUserId());
        return ResponseEntity.ok(ApiResponse.success(result));
    }

    /**
     * 아이템 생성
     */
    @PostMapping
    public ResponseEntity<ApiResponse<ItemResponse>> createItem(
            @PathVariable Long boardId,
            @Valid @RequestBody ItemCreateRequest request,
            @CurrentUser UserPrincipal currentUser) {

        ItemResponse result = itemService.createItem(boardId, request, currentUser.getUserId());
        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(result));
    }

    /**
     * 아이템 수정
     */
    @PutMapping("/{itemId}")
    public ResponseEntity<ApiResponse<ItemResponse>> updateItem(
            @PathVariable Long boardId,
            @PathVariable Long itemId,
            @Valid @RequestBody ItemUpdateRequest request,
            @CurrentUser UserPrincipal currentUser) {

        ItemResponse result = itemService.updateItem(boardId, itemId, request, currentUser.getUserId());
        return ResponseEntity.ok(ApiResponse.success(result));
    }

    /**
     * 아이템 삭제
     */
    @DeleteMapping("/{itemId}")
    public ResponseEntity<Void> deleteItem(
            @PathVariable Long boardId,
            @PathVariable Long itemId,
            @CurrentUser UserPrincipal currentUser) {

        itemService.deleteItem(boardId, itemId, currentUser.getUserId());
        return ResponseEntity.noContent().build();
    }
}
```

### 6.3 Service 작성 규칙

```java
// 인터페이스
public interface ItemService {
    PageResponse<ItemResponse> getItems(Long boardId, ItemSearchRequest request, Long userId);
    ItemResponse getItem(Long boardId, Long itemId, Long userId);
    ItemResponse createItem(Long boardId, ItemCreateRequest request, Long userId);
    ItemResponse updateItem(Long boardId, Long itemId, ItemUpdateRequest request, Long userId);
    void deleteItem(Long boardId, Long itemId, Long userId);
}

// 구현 클래스
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class ItemServiceImpl implements ItemService {

    private final ItemMapper itemMapper;
    private final BoardService boardService;
    private final SseEventPublisher sseEventPublisher;

    @Override
    public PageResponse<ItemResponse> getItems(Long boardId, ItemSearchRequest request, Long userId) {
        // 권한 확인
        boardService.checkBoardAccess(boardId, userId);

        // 데이터 조회
        List<Item> items = itemMapper.findByBoardId(boardId, request);
        int total = itemMapper.countByBoardId(boardId, request);

        // 응답 변환
        List<ItemResponse> responses = items.stream()
                .map(ItemResponse::from)
                .toList();

        return PageResponse.of(responses, request.getPage(), request.getSize(), total);
    }

    @Override
    @Transactional
    public ItemResponse createItem(Long boardId, ItemCreateRequest request, Long userId) {
        // 권한 확인
        boardService.checkBoardEditAccess(boardId, userId);

        // 엔티티 생성
        Item item = Item.builder()
                .boardId(boardId)
                .content(request.getContent())
                .status(ItemStatus.NOT_STARTED)
                .priority(request.getPriority())
                .createdBy(userId)
                .build();

        // 저장
        itemMapper.insert(item);

        // SSE 이벤트 발행
        sseEventPublisher.publishItemCreated(boardId, item.getItemId());

        return getItem(boardId, item.getItemId(), userId);
    }

    // ... 기타 메서드
}
```

### 6.4 MyBatis Mapper 작성 규칙

**Mapper 인터페이스:**

```java
@Mapper
public interface ItemMapper {

    List<Item> findByBoardId(@Param("boardId") Long boardId, @Param("request") ItemSearchRequest request);

    int countByBoardId(@Param("boardId") Long boardId, @Param("request") ItemSearchRequest request);

    Item findById(@Param("itemId") Long itemId);

    void insert(Item item);

    void update(Item item);

    void delete(@Param("itemId") Long itemId, @Param("userId") Long userId);
}
```

**XML Mapper:**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.taskflow.mapper.ItemMapper">

    <!-- 결과 매핑 -->
    <resultMap id="itemResultMap" type="Item">
        <id property="itemId" column="ITEM_ID"/>
        <result property="boardId" column="BOARD_ID"/>
        <result property="content" column="CONTENT"/>
        <result property="description" column="DESCRIPTION"/>
        <result property="status" column="STATUS"/>
        <result property="priority" column="PRIORITY"/>
        <result property="categoryId" column="CATEGORY_ID"/>
        <result property="groupId" column="GROUP_ID"/>
        <result property="assigneeId" column="ASSIGNEE_ID"/>
        <result property="startTime" column="START_TIME"/>
        <result property="endTime" column="END_TIME"/>
        <result property="createdAt" column="CREATED_AT"/>
        <result property="createdBy" column="CREATED_BY"/>
        <result property="updatedAt" column="UPDATED_AT"/>
        <result property="updatedBy" column="UPDATED_BY"/>
    </resultMap>

    <!-- 목록 조회 -->
    <select id="findByBoardId" resultMap="itemResultMap">
        SELECT
            i.ITEM_ID,
            i.BOARD_ID,
            i.CONTENT,
            i.DESCRIPTION,
            i.STATUS,
            i.PRIORITY,
            i.CATEGORY_ID,
            i.GROUP_ID,
            i.ASSIGNEE_ID,
            i.START_TIME,
            i.END_TIME,
            i.CREATED_AT,
            i.CREATED_BY,
            i.UPDATED_AT,
            i.UPDATED_BY
        FROM TB_ITEM i
        WHERE i.BOARD_ID = #{boardId}
        <if test="request.status != null">
            AND i.STATUS = #{request.status}
        </if>
        <if test="request.priority != null">
            AND i.PRIORITY = #{request.priority}
        </if>
        <if test="request.assigneeId != null">
            AND i.ASSIGNEE_ID = #{request.assigneeId}
        </if>
        <if test="request.keyword != null and request.keyword != ''">
            AND i.CONTENT LIKE CONCAT('%', #{request.keyword}, '%')
        </if>
        ORDER BY
        <choose>
            <when test="request.sortField == 'createdAt'">
                i.CREATED_AT
            </when>
            <when test="request.sortField == 'priority'">
                FIELD(i.PRIORITY, 'URGENT', 'HIGH', 'NORMAL', 'LOW')
            </when>
            <otherwise>
                i.CREATED_AT
            </otherwise>
        </choose>
        <if test="request.sortDirection == 'desc'">
            DESC
        </if>
        <if test="request.sortDirection == 'asc' or request.sortDirection == null">
            ASC
        </if>
        LIMIT #{request.offset}, #{request.size}
    </select>

    <!-- 단건 조회 -->
    <select id="findById" resultMap="itemResultMap">
        SELECT * FROM TB_ITEM WHERE ITEM_ID = #{itemId}
    </select>

    <!-- 등록 -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="itemId">
        INSERT INTO TB_ITEM (
            BOARD_ID, CONTENT, DESCRIPTION, STATUS, PRIORITY,
            CATEGORY_ID, GROUP_ID, ASSIGNEE_ID, START_TIME, END_TIME,
            CREATED_BY
        ) VALUES (
            #{boardId}, #{content}, #{description}, #{status}, #{priority},
            #{categoryId}, #{groupId}, #{assigneeId}, #{startTime}, #{endTime},
            #{createdBy}
        )
    </insert>

    <!-- 수정 -->
    <update id="update">
        UPDATE TB_ITEM
        SET
            CONTENT = #{content},
            DESCRIPTION = #{description},
            STATUS = #{status},
            PRIORITY = #{priority},
            CATEGORY_ID = #{categoryId},
            GROUP_ID = #{groupId},
            ASSIGNEE_ID = #{assigneeId},
            START_TIME = #{startTime},
            END_TIME = #{endTime},
            UPDATED_BY = #{updatedBy}
        WHERE ITEM_ID = #{itemId}
    </update>

    <!-- 삭제 (소프트 삭제) -->
    <update id="delete">
        UPDATE TB_ITEM
        SET
            STATUS = 'DELETED',
            DELETED_AT = NOW(),
            DELETED_BY = #{userId},
            UPDATED_BY = #{userId}
        WHERE ITEM_ID = #{itemId}
    </update>

</mapper>
```

### 6.5 DTO 작성 규칙

```java
// Request DTO
@Data
@NoArgsConstructor
public class ItemCreateRequest {

    @NotBlank(message = "업무 내용은 필수입니다")
    @Size(max = 500, message = "업무 내용은 500자 이하로 입력해주세요")
    private String content;

    private String description;

    private String priority = "NORMAL";

    private Long categoryId;

    private Long groupId;

    private Long assigneeId;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime startTime;

    @JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime endTime;
}

// Response DTO
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class ItemResponse {

    private Long itemId;
    private Long boardId;
    private String content;
    private String description;
    private String status;
    private String priority;
    private Long categoryId;
    private String categoryName;
    private Long groupId;
    private String groupName;
    private Long assigneeId;
    private String assigneeName;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private Integer commentCount;
    private LocalDateTime createdAt;
    private Long createdBy;
    private String createdByName;
    private LocalDateTime updatedAt;
    private Long updatedBy;

    public static ItemResponse from(Item item) {
        return ItemResponse.builder()
                .itemId(item.getItemId())
                .boardId(item.getBoardId())
                .content(item.getContent())
                .description(item.getDescription())
                .status(item.getStatus())
                .priority(item.getPriority())
                .categoryId(item.getCategoryId())
                .groupId(item.getGroupId())
                .assigneeId(item.getAssigneeId())
                .startTime(item.getStartTime())
                .endTime(item.getEndTime())
                .createdAt(item.getCreatedAt())
                .createdBy(item.getCreatedBy())
                .updatedAt(item.getUpdatedAt())
                .updatedBy(item.getUpdatedBy())
                .build();
    }
}
```

### 6.6 API 응답 표준

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {

    private boolean success;
    private T data;
    private String message;

    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, data, null);
    }

    public static <T> ApiResponse<T> success(T data, String message) {
        return new ApiResponse<>(true, data, message);
    }

    public static <T> ApiResponse<T> error(String message) {
        return new ApiResponse<>(false, null, message);
    }
}
```

---

## 7. 프론트엔드 개발 가이드

### 7.1 Composition API 패턴

```vue
<script setup lang="ts">
import { ref, computed, onMounted, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { storeToRefs } from 'pinia'

// Store Import
import { useItemStore } from '@/stores/item'
import { useBoardStore } from '@/stores/board'

// Composable Import
import { useToast } from '@/composables/useToast'
import { useConfirm } from '@/composables/useConfirm'
import { useLoading } from '@/composables/useLoading'

// API Import
import { itemApi } from '@/api/item'

// Type Import
import type { Item, ItemCreateRequest } from '@/types/item'

// Props 정의
interface Props {
  boardId: number
  editable?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  editable: true
})

// Emit 정의
const emit = defineEmits<{
  (e: 'select', item: Item): void
  (e: 'update', item: Item): void
  (e: 'delete', itemId: number): void
}>()

// Store
const itemStore = useItemStore()
const boardStore = useBoardStore()
const { items, loading: itemLoading } = storeToRefs(itemStore)

// Composables
const { showToast } = useToast()
const { confirm } = useConfirm()
const { isLoading, startLoading, stopLoading } = useLoading()

// Router
const route = useRoute()
const router = useRouter()

// Reactive State
const searchKeyword = ref('')
const selectedItemId = ref<number | null>(null)
const isFormVisible = ref(false)

// Computed
const filteredItems = computed(() => {
  if (!searchKeyword.value) return items.value

  return items.value.filter(item =>
    item.content.toLowerCase().includes(searchKeyword.value.toLowerCase())
  )
})

const currentBoard = computed(() =>
  boardStore.boards.find(b => b.boardId === props.boardId)
)

// Methods
async function fetchItems() {
  startLoading()
  try {
    await itemStore.fetchItems(props.boardId)
  } catch (error) {
    showToast('업무 목록을 불러오는데 실패했습니다', 'error')
  } finally {
    stopLoading()
  }
}

async function handleCreate(request: ItemCreateRequest) {
  try {
    const item = await itemApi.createItem(props.boardId, request)
    showToast('업무가 등록되었습니다', 'success')
    emit('update', item)
    isFormVisible.value = false
  } catch (error) {
    showToast('업무 등록에 실패했습니다', 'error')
  }
}

async function handleDelete(itemId: number) {
  const confirmed = await confirm({
    title: '업무 삭제',
    message: '정말 이 업무를 삭제하시겠습니까?',
    confirmText: '삭제',
    cancelText: '취소'
  })

  if (confirmed) {
    try {
      await itemStore.deleteItem(props.boardId, itemId)
      showToast('업무가 삭제되었습니다', 'success')
      emit('delete', itemId)
    } catch (error) {
      showToast('업무 삭제에 실패했습니다', 'error')
    }
  }
}

function handleSelect(item: Item) {
  selectedItemId.value = item.itemId
  emit('select', item)
}

// Watchers
watch(() => props.boardId, (newBoardId) => {
  if (newBoardId) {
    fetchItems()
  }
})

// Lifecycle
onMounted(() => {
  fetchItems()
})
</script>

<template>
  <div class="item-list">
    <!-- 검색 -->
    <div class="mb-4">
      <Input
        v-model="searchKeyword"
        placeholder="업무 검색..."
        :disabled="isLoading"
      />
    </div>

    <!-- 로딩 -->
    <Spinner v-if="isLoading" />

    <!-- 업무 목록 -->
    <div v-else class="space-y-2">
      <ItemRow
        v-for="item in filteredItems"
        :key="item.itemId"
        :item="item"
        :selected="selectedItemId === item.itemId"
        :editable="editable"
        @click="handleSelect(item)"
        @delete="handleDelete(item.itemId)"
      />

      <!-- 빈 상태 -->
      <EmptyState
        v-if="filteredItems.length === 0"
        message="등록된 업무가 없습니다"
      />
    </div>

    <!-- 등록 버튼 -->
    <Button
      v-if="editable"
      @click="isFormVisible = true"
      class="mt-4"
    >
      새 업무 등록
    </Button>

    <!-- 등록 폼 모달 -->
    <Modal v-model:visible="isFormVisible" title="새 업무 등록">
      <ItemForm @submit="handleCreate" @cancel="isFormVisible = false" />
    </Modal>
  </div>
</template>

<style scoped>
.item-list {
  @apply p-4;
}
</style>
```

### 7.2 Pinia Store 패턴

```typescript
// stores/item.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { itemApi } from '@/api/item'
import type { Item, ItemCreateRequest, ItemUpdateRequest } from '@/types/item'

export const useItemStore = defineStore('item', () => {
  // State
  const items = ref<Item[]>([])
  const currentItem = ref<Item | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)

  // Getters
  const getItemById = computed(() => {
    return (itemId: number) => items.value.find(item => item.itemId === itemId)
  })

  const itemsByStatus = computed(() => {
    return (status: string) => items.value.filter(item => item.status === status)
  })

  const pendingItems = computed(() =>
    items.value.filter(item => item.status !== 'COMPLETED' && item.status !== 'DELETED')
  )

  // Actions
  async function fetchItems(boardId: number, params?: Record<string, any>) {
    loading.value = true
    error.value = null

    try {
      const response = await itemApi.getItems(boardId, params)
      items.value = response.data.content
      return response.data
    } catch (e: any) {
      error.value = e.message || '업무 목록을 불러오는데 실패했습니다'
      throw e
    } finally {
      loading.value = false
    }
  }

  async function fetchItem(boardId: number, itemId: number) {
    loading.value = true
    error.value = null

    try {
      const response = await itemApi.getItem(boardId, itemId)
      currentItem.value = response.data

      // 목록에 있으면 업데이트
      const index = items.value.findIndex(item => item.itemId === itemId)
      if (index !== -1) {
        items.value[index] = response.data
      }

      return response.data
    } catch (e: any) {
      error.value = e.message || '업무를 불러오는데 실패했습니다'
      throw e
    } finally {
      loading.value = false
    }
  }

  async function createItem(boardId: number, request: ItemCreateRequest) {
    loading.value = true
    error.value = null

    try {
      const response = await itemApi.createItem(boardId, request)
      items.value.unshift(response.data)
      return response.data
    } catch (e: any) {
      error.value = e.message || '업무 등록에 실패했습니다'
      throw e
    } finally {
      loading.value = false
    }
  }

  async function updateItem(boardId: number, itemId: number, request: ItemUpdateRequest) {
    // Optimistic Update
    const index = items.value.findIndex(item => item.itemId === itemId)
    const originalItem = index !== -1 ? { ...items.value[index] } : null

    if (index !== -1) {
      items.value[index] = { ...items.value[index], ...request }
    }

    try {
      const response = await itemApi.updateItem(boardId, itemId, request)

      if (index !== -1) {
        items.value[index] = response.data
      }

      if (currentItem.value?.itemId === itemId) {
        currentItem.value = response.data
      }

      return response.data
    } catch (e: any) {
      // Rollback
      if (originalItem && index !== -1) {
        items.value[index] = originalItem
      }

      error.value = e.message || '업무 수정에 실패했습니다'
      throw e
    }
  }

  async function deleteItem(boardId: number, itemId: number) {
    try {
      await itemApi.deleteItem(boardId, itemId)
      items.value = items.value.filter(item => item.itemId !== itemId)

      if (currentItem.value?.itemId === itemId) {
        currentItem.value = null
      }
    } catch (e: any) {
      error.value = e.message || '업무 삭제에 실패했습니다'
      throw e
    }
  }

  // SSE 이벤트 핸들러
  function handleSseEvent(event: { type: string; payload: any }) {
    switch (event.type) {
      case 'item:created':
        // 다른 사용자가 생성한 경우에만 추가
        if (!items.value.find(item => item.itemId === event.payload.itemId)) {
          fetchItem(event.payload.boardId, event.payload.itemId)
            .then(item => items.value.unshift(item))
            .catch(() => {})
        }
        break

      case 'item:updated':
        fetchItem(event.payload.boardId, event.payload.itemId).catch(() => {})
        break

      case 'item:deleted':
        items.value = items.value.filter(item => item.itemId !== event.payload.itemId)
        break
    }
  }

  // Reset
  function $reset() {
    items.value = []
    currentItem.value = null
    loading.value = false
    error.value = null
  }

  return {
    // State
    items,
    currentItem,
    loading,
    error,

    // Getters
    getItemById,
    itemsByStatus,
    pendingItems,

    // Actions
    fetchItems,
    fetchItem,
    createItem,
    updateItem,
    deleteItem,
    handleSseEvent,
    $reset
  }
})
```

### 7.3 API 모듈 패턴

```typescript
// api/client.ts
import axios, { type AxiosInstance, type AxiosError } from 'axios'
import { useAuthStore } from '@/stores/auth'
import router from '@/router'

const client: AxiosInstance = axios.create({
  baseURL: '/api',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// Request Interceptor
client.interceptors.request.use(
  (config) => {
    const authStore = useAuthStore()
    const token = authStore.accessToken

    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }

    return config
  },
  (error) => Promise.reject(error)
)

// Response Interceptor
client.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const authStore = useAuthStore()

    if (error.response?.status === 401) {
      // 토큰 갱신 시도
      try {
        await authStore.refreshToken()
        // 원래 요청 재시도
        return client.request(error.config!)
      } catch {
        // 갱신 실패 시 로그아웃
        authStore.logout()
        router.push('/login')
      }
    }

    return Promise.reject(error)
  }
)

export default client

// api/item.ts
import client from './client'
import type { ApiResponse, PageResponse } from '@/types/api'
import type { Item, ItemCreateRequest, ItemUpdateRequest } from '@/types/item'

export const itemApi = {
  // 목록 조회
  getItems(boardId: number, params?: Record<string, any>) {
    return client.get<ApiResponse<PageResponse<Item>>>(
      `/boards/${boardId}/items`,
      { params }
    )
  },

  // 단건 조회
  getItem(boardId: number, itemId: number) {
    return client.get<ApiResponse<Item>>(
      `/boards/${boardId}/items/${itemId}`
    )
  },

  // 생성
  createItem(boardId: number, request: ItemCreateRequest) {
    return client.post<ApiResponse<Item>>(
      `/boards/${boardId}/items`,
      request
    )
  },

  // 수정
  updateItem(boardId: number, itemId: number, request: ItemUpdateRequest) {
    return client.put<ApiResponse<Item>>(
      `/boards/${boardId}/items/${itemId}`,
      request
    )
  },

  // 삭제
  deleteItem(boardId: number, itemId: number) {
    return client.delete<void>(
      `/boards/${boardId}/items/${itemId}`
    )
  },

  // 완료 처리
  completeItem(boardId: number, itemId: number) {
    return client.put<ApiResponse<Item>>(
      `/boards/${boardId}/items/${itemId}/complete`
    )
  },

  // 복원
  restoreItem(boardId: number, itemId: number) {
    return client.put<ApiResponse<Item>>(
      `/boards/${boardId}/items/${itemId}/restore`
    )
  }
}
```

### 7.4 TypeScript 타입 정의

```typescript
// types/item.ts
export type ItemStatus = 'NOT_STARTED' | 'IN_PROGRESS' | 'COMPLETED' | 'DELETED'
export type ItemPriority = 'URGENT' | 'HIGH' | 'NORMAL' | 'LOW'

export interface Item {
  itemId: number
  boardId: number
  content: string
  description?: string
  status: ItemStatus
  priority: ItemPriority
  categoryId?: number
  categoryName?: string
  groupId?: number
  groupName?: string
  assigneeId?: number
  assigneeName?: string
  startTime?: string
  endTime?: string
  commentCount?: number
  transferredFrom?: number
  transferredAt?: string
  createdAt: string
  createdBy: number
  createdByName?: string
  updatedAt?: string
  updatedBy?: number
}

export interface ItemCreateRequest {
  content: string
  description?: string
  priority?: ItemPriority
  categoryId?: number
  groupId?: number
  assigneeId?: number
  startTime?: string
  endTime?: string
  properties?: ItemPropertyValue[]
}

export interface ItemUpdateRequest {
  content?: string
  description?: string
  status?: ItemStatus
  priority?: ItemPriority
  categoryId?: number
  groupId?: number
  assigneeId?: number
  startTime?: string
  endTime?: string
  properties?: ItemPropertyValue[]
}

export interface ItemPropertyValue {
  propertyId: number
  valueText?: string
  valueNumber?: number
  valueDate?: string
  valueOptionId?: number
  valueUserId?: number
  valueCheckbox?: boolean
  optionIds?: number[]  // MULTI_SELECT용
}

export interface ItemSearchRequest {
  page?: number
  size?: number
  status?: ItemStatus
  priority?: ItemPriority
  assigneeId?: number
  groupId?: number
  keyword?: string
  startDate?: string
  endDate?: string
  sortField?: string
  sortDirection?: 'asc' | 'desc'
  includeCompleted?: boolean
  includeDeleted?: boolean
}
```

### 7.5 Composable 패턴

```typescript
// composables/useToast.ts
import { ref } from 'vue'

export type ToastType = 'success' | 'error' | 'warning' | 'info'

interface Toast {
  id: number
  message: string
  type: ToastType
  duration: number
}

const toasts = ref<Toast[]>([])
let nextId = 0

export function useToast() {
  function showToast(message: string, type: ToastType = 'info', duration = 3000) {
    const id = nextId++

    toasts.value.push({ id, message, type, duration })

    if (duration > 0) {
      setTimeout(() => {
        removeToast(id)
      }, duration)
    }

    return id
  }

  function removeToast(id: number) {
    const index = toasts.value.findIndex(t => t.id === id)
    if (index !== -1) {
      toasts.value.splice(index, 1)
    }
  }

  return {
    toasts,
    showToast,
    removeToast
  }
}

// composables/useDebounce.ts
import { ref, watch, type Ref } from 'vue'

export function useDebounce<T>(source: Ref<T>, delay = 300) {
  const debounced = ref<T>(source.value) as Ref<T>
  let timeout: ReturnType<typeof setTimeout>

  watch(source, (newValue) => {
    clearTimeout(timeout)
    timeout = setTimeout(() => {
      debounced.value = newValue
    }, delay)
  })

  return debounced
}

// composables/useConfirm.ts
import { ref } from 'vue'

interface ConfirmOptions {
  title: string
  message: string
  confirmText?: string
  cancelText?: string
  type?: 'warning' | 'danger' | 'info'
}

const isOpen = ref(false)
const options = ref<ConfirmOptions | null>(null)
let resolvePromise: ((value: boolean) => void) | null = null

export function useConfirm() {
  function confirm(opts: ConfirmOptions): Promise<boolean> {
    options.value = {
      confirmText: '확인',
      cancelText: '취소',
      type: 'warning',
      ...opts
    }
    isOpen.value = true

    return new Promise((resolve) => {
      resolvePromise = resolve
    })
  }

  function handleConfirm() {
    isOpen.value = false
    resolvePromise?.(true)
    resolvePromise = null
    options.value = null
  }

  function handleCancel() {
    isOpen.value = false
    resolvePromise?.(false)
    resolvePromise = null
    options.value = null
  }

  return {
    isOpen,
    options,
    confirm,
    handleConfirm,
    handleCancel
  }
}
```

---

## 8. 인증 및 보안

### 8.1 JWT 인증 흐름

```
┌────────────────────────────────────────────────────────────────────────┐
│                         JWT Authentication Flow                         │
└────────────────────────────────────────────────────────────────────────┘

1. Login Request
┌────────┐                    ┌────────────────┐                    ┌────────┐
│ Client │─── POST /login ──▶│ AuthController │───▶ Validate ───▶│  MySQL │
└────────┘   username/password└────────────────┘    Credentials    └────────┘
                                    │
                                    ▼
                           ┌────────────────┐
                           │ Generate Tokens│
                           │ - Access (30m) │
                           │ - Refresh (7d) │
                           └────────────────┘
                                    │
                                    ▼
┌────────┐                    ┌────────────────┐
│ Client │◀─── Response ─────│                │
└────────┘  {accessToken,    │                │
            refreshToken}    │                │
                             └────────────────┘

2. API Request with Token
┌────────┐                    ┌────────────────┐                    ┌────────┐
│ Client │─── GET /api/** ──▶│  JwtFilter     │───▶ Validate ───▶│ Service │
└────────┘   Authorization:   │  (Intercept)   │    Token          └────────┘
             Bearer {token}   └────────────────┘
                                    │
                                    ▼
                           ┌────────────────┐
                           │ Extract User   │
                           │ Set Security   │
                           │ Context        │
                           └────────────────┘

3. Token Refresh
┌────────┐                    ┌────────────────┐
│ Client │─── POST /refresh ─▶│ AuthController │
└────────┘   {refreshToken}   └────────────────┘
                                    │
                                    ▼
                           ┌────────────────┐
                           │ Validate       │
                           │ Refresh Token  │
                           │ Generate New   │
                           │ Access Token   │
                           └────────────────┘
                                    │
┌────────┐                          │
│ Client │◀─── {accessToken} ───────┘
└────────┘
```

### 8.2 Security Configuration

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    private final JwtAccessDeniedHandler jwtAccessDeniedHandler;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // CSRF 비활성화 (JWT 사용)
            .csrf(csrf -> csrf.disable())

            // 세션 비활성화 (Stateless)
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )

            // 예외 처리
            .exceptionHandling(exception -> exception
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)
                .accessDeniedHandler(jwtAccessDeniedHandler)
            )

            // 권한 설정
            .authorizeHttpRequests(auth -> auth
                // 인증 없이 접근 가능
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/health").permitAll()
                .requestMatchers("/api/sse/**").permitAll()

                // 나머지는 인증 필요
                .anyRequest().authenticated()
            )

            // JWT 필터 추가
            .addFilterBefore(jwtAuthenticationFilter,
                UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 8.3 JWT Filter

```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;
    private final UserService userService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain)
            throws ServletException, IOException {

        try {
            String token = getTokenFromRequest(request);

            if (StringUtils.hasText(token) && tokenProvider.validateToken(token)) {
                Long userId = tokenProvider.getUserIdFromToken(token);

                UserDetails userDetails = userService.loadUserById(userId);

                UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities()
                    );

                authentication.setDetails(
                    new WebAuthenticationDetailsSource().buildDetails(request)
                );

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception e) {
            log.error("Could not set user authentication in security context", e);
        }

        filterChain.doFilter(request, response);
    }

    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 8.4 권한 체계

| 권한 | 설명 | 보드 접근 | 업무 수정 | 공유 관리 | 보드 삭제 |
|------|------|----------|----------|----------|----------|
| **OWNER** | 보드 소유자 | O | O | O | O |
| **FULL** | 전체 권한 | O | O | O | X |
| **EDIT** | 편집 권한 | O | O | X | X |
| **VIEW** | 조회 권한 | O | X | X | X |

### 8.5 비밀번호 정책

```java
public class PasswordValidator {

    private static final int MIN_LENGTH = 8;
    private static final Pattern UPPERCASE = Pattern.compile("[A-Z]");
    private static final Pattern LOWERCASE = Pattern.compile("[a-z]");
    private static final Pattern DIGIT = Pattern.compile("[0-9]");
    private static final Pattern SPECIAL = Pattern.compile("[!@#$%^&*]");

    public static List<String> validate(String password) {
        List<String> errors = new ArrayList<>();

        if (password == null || password.length() < MIN_LENGTH) {
            errors.add("비밀번호는 최소 " + MIN_LENGTH + "자 이상이어야 합니다");
        }

        if (!UPPERCASE.matcher(password).find()) {
            errors.add("대문자를 1개 이상 포함해야 합니다");
        }

        if (!LOWERCASE.matcher(password).find()) {
            errors.add("소문자를 1개 이상 포함해야 합니다");
        }

        if (!DIGIT.matcher(password).find()) {
            errors.add("숫자를 1개 이상 포함해야 합니다");
        }

        if (!SPECIAL.matcher(password).find()) {
            errors.add("특수문자(!@#$%^&*)를 1개 이상 포함해야 합니다");
        }

        return errors;
    }
}
```

---

## 9. 실시간 동기화 (SSE)

### 9.1 SSE 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        SSE (Server-Sent Events)                          │
└─────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────┐
│                            Backend                                      │
│                                                                         │
│  ┌──────────────────┐     ┌─────────────────┐     ┌─────────────────┐ │
│  │   SseController  │     │ SseEmitterManager│     │ SseEventPublisher│ │
│  │                  │     │                 │     │                 │ │
│  │ GET /sse/subscribe     │ - emitters Map  │     │ publishEvent()  │ │
│  │ → Create Emitter│─────▶│ - Board Mapping │◀────│ - Board Events  │ │
│  │                  │     │ - Connection Mgmt│     │ - Item Events   │ │
│  └──────────────────┘     └─────────────────┘     └─────────────────┘ │
│           │                       │                       ▲           │
│           │                       │                       │           │
│           ▼                       ▼                       │           │
│  ┌──────────────────────────────────────────┐            │           │
│  │              Event Flow                   │            │           │
│  │                                           │            │           │
│  │  Client Subscribe → Store Emitter         │            │           │
│  │  Service Action → Publish Event ──────────┼────────────┘           │
│  │  Find Emitters → Send to All Subscribers  │                        │
│  └──────────────────────────────────────────┘                         │
└────────────────────────────────────────────────────────────────────────┘
          │
          │  SSE Connection (text/event-stream)
          ▼
┌────────────────────────────────────────────────────────────────────────┐
│                            Frontend                                     │
│                                                                         │
│  ┌──────────────────┐     ┌─────────────────┐     ┌─────────────────┐ │
│  │    useSse.ts     │     │    sseStore     │     │  Component      │ │
│  │                  │     │                 │     │                 │ │
│  │ EventSource      │─────▶│ Handle Events   │─────▶│ Reactive Update │ │
│  │ - Auto Reconnect │     │ - Update Store  │     │ - Re-render     │ │
│  │ - Error Handling │     │ - Notify User   │     │                 │ │
│  └──────────────────┘     └─────────────────┘     └─────────────────┘ │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### 9.2 Backend SSE 구현

```java
// SseController.java
@RestController
@RequestMapping("/api/sse")
@RequiredArgsConstructor
public class SseController {

    private final SseEmitterManager emitterManager;

    @GetMapping(value = "/subscribe", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(
            @RequestParam Long boardId,
            @CurrentUser UserPrincipal currentUser) {

        return emitterManager.createEmitter(boardId, currentUser.getUserId());
    }
}

// SseEmitterManager.java
@Component
@Slf4j
public class SseEmitterManager {

    private static final Long DEFAULT_TIMEOUT = 60L * 1000 * 60; // 1시간

    // boardId -> List<Emitter>
    private final Map<Long, List<SseEmitterWrapper>> emitters = new ConcurrentHashMap<>();

    public SseEmitter createEmitter(Long boardId, Long userId) {
        SseEmitter emitter = new SseEmitter(DEFAULT_TIMEOUT);
        SseEmitterWrapper wrapper = new SseEmitterWrapper(emitter, userId);

        // 보드별 이미터 목록에 추가
        emitters.computeIfAbsent(boardId, k -> new CopyOnWriteArrayList<>()).add(wrapper);

        // 연결 종료 시 제거
        emitter.onCompletion(() -> removeEmitter(boardId, wrapper));
        emitter.onTimeout(() -> removeEmitter(boardId, wrapper));
        emitter.onError(e -> removeEmitter(boardId, wrapper));

        // 초기 연결 확인 이벤트
        try {
            emitter.send(SseEmitter.event()
                    .name("connected")
                    .data(Map.of("boardId", boardId, "userId", userId)));
        } catch (IOException e) {
            log.error("Failed to send initial event", e);
        }

        return emitter;
    }

    public void sendToBoard(Long boardId, String eventName, Object data) {
        List<SseEmitterWrapper> boardEmitters = emitters.get(boardId);
        if (boardEmitters == null || boardEmitters.isEmpty()) {
            return;
        }

        List<SseEmitterWrapper> failedEmitters = new ArrayList<>();

        for (SseEmitterWrapper wrapper : boardEmitters) {
            try {
                wrapper.getEmitter().send(SseEmitter.event()
                        .name(eventName)
                        .data(data));
            } catch (IOException e) {
                failedEmitters.add(wrapper);
            }
        }

        // 실패한 이미터 제거
        failedEmitters.forEach(wrapper -> removeEmitter(boardId, wrapper));
    }

    private void removeEmitter(Long boardId, SseEmitterWrapper wrapper) {
        List<SseEmitterWrapper> boardEmitters = emitters.get(boardId);
        if (boardEmitters != null) {
            boardEmitters.remove(wrapper);
            if (boardEmitters.isEmpty()) {
                emitters.remove(boardId);
            }
        }
    }
}

// SseEventPublisher.java
@Component
@RequiredArgsConstructor
public class SseEventPublisher {

    private final SseEmitterManager emitterManager;

    public void publishItemCreated(Long boardId, Long itemId) {
        emitterManager.sendToBoard(boardId, "item:created",
            Map.of("boardId", boardId, "itemId", itemId));
    }

    public void publishItemUpdated(Long boardId, Long itemId) {
        emitterManager.sendToBoard(boardId, "item:updated",
            Map.of("boardId", boardId, "itemId", itemId));
    }

    public void publishItemDeleted(Long boardId, Long itemId) {
        emitterManager.sendToBoard(boardId, "item:deleted",
            Map.of("boardId", boardId, "itemId", itemId));
    }

    public void publishCommentCreated(Long boardId, Long itemId, Long commentId) {
        emitterManager.sendToBoard(boardId, "comment:created",
            Map.of("boardId", boardId, "itemId", itemId, "commentId", commentId));
    }

    public void publishPropertyUpdated(Long boardId, Long propertyId) {
        emitterManager.sendToBoard(boardId, "property:updated",
            Map.of("boardId", boardId, "propertyId", propertyId));
    }
}
```

### 9.3 Frontend SSE 구현

```typescript
// composables/useSse.ts
import { ref, onUnmounted } from 'vue'
import { useItemStore } from '@/stores/item'
import { usePropertyStore } from '@/stores/property'

export function useSse(boardId: number) {
  const eventSource = ref<EventSource | null>(null)
  const isConnected = ref(false)
  const reconnectAttempts = ref(0)
  const maxReconnectAttempts = 5
  const reconnectDelay = 3000

  const itemStore = useItemStore()
  const propertyStore = usePropertyStore()

  function connect() {
    if (eventSource.value) {
      eventSource.value.close()
    }

    const url = `/api/sse/subscribe?boardId=${boardId}`
    eventSource.value = new EventSource(url)

    eventSource.value.onopen = () => {
      isConnected.value = true
      reconnectAttempts.value = 0
      console.log('SSE connected')
    }

    eventSource.value.onerror = (error) => {
      console.error('SSE error:', error)
      isConnected.value = false
      eventSource.value?.close()

      // 자동 재연결
      if (reconnectAttempts.value < maxReconnectAttempts) {
        reconnectAttempts.value++
        setTimeout(connect, reconnectDelay)
      }
    }

    // 이벤트 핸들러 등록
    eventSource.value.addEventListener('connected', (event) => {
      console.log('SSE connected:', JSON.parse(event.data))
    })

    eventSource.value.addEventListener('item:created', (event) => {
      const data = JSON.parse(event.data)
      itemStore.handleSseEvent({ type: 'item:created', payload: data })
    })

    eventSource.value.addEventListener('item:updated', (event) => {
      const data = JSON.parse(event.data)
      itemStore.handleSseEvent({ type: 'item:updated', payload: data })
    })

    eventSource.value.addEventListener('item:deleted', (event) => {
      const data = JSON.parse(event.data)
      itemStore.handleSseEvent({ type: 'item:deleted', payload: data })
    })

    eventSource.value.addEventListener('property:updated', (event) => {
      const data = JSON.parse(event.data)
      propertyStore.handleSseEvent({ type: 'property:updated', payload: data })
    })
  }

  function disconnect() {
    if (eventSource.value) {
      eventSource.value.close()
      eventSource.value = null
      isConnected.value = false
    }
  }

  onUnmounted(() => {
    disconnect()
  })

  return {
    isConnected,
    connect,
    disconnect
  }
}
```

### 9.4 SSE 이벤트 타입

| 이벤트 | 설명 | Payload |
|--------|------|---------|
| `connected` | 연결 성공 | `{ boardId, userId }` |
| `item:created` | 업무 생성 | `{ boardId, itemId }` |
| `item:updated` | 업무 수정 | `{ boardId, itemId }` |
| `item:deleted` | 업무 삭제 | `{ boardId, itemId }` |
| `comment:created` | 댓글 생성 | `{ boardId, itemId, commentId }` |
| `property:updated` | 속성 수정 | `{ boardId, propertyId }` |

---

## 10. 개발 환경 설정

### 10.1 사전 요구사항

| 도구 | 최소 버전 | 권장 버전 |
|------|----------|----------|
| JDK | 17 | 21 LTS |
| Node.js | 18 | 20 LTS |
| npm | 9 | 10 |
| Docker | 24 | 최신 |
| Docker Compose | 2.0 | 최신 |
| VS Code | - | 최신 |

### 10.2 개발 환경 구성

#### 10.2.1 프로젝트 클론

```bash
git clone https://github.com/your-org/taskflow.git
cd taskflow
```

#### 10.2.2 Docker 환경 실행 (MySQL)

```bash
# MySQL만 실행
docker compose up -d mysql

# 로그 확인
docker compose logs -f mysql
```

#### 10.2.3 Backend 실행

```bash
cd backend

# Gradle Wrapper 권한 부여 (Linux/Mac)
chmod +x gradlew

# 의존성 다운로드 및 빌드
./gradlew build -x test

# 애플리케이션 실행
./gradlew bootRun
```

#### 10.2.4 Frontend 실행

```bash
cd frontend

# 의존성 설치
npm install

# 개발 서버 실행
npm run dev
```

### 10.3 VS Code 확장 프로그램

**필수:**
- Vue - Official (Vue.volar)
- ESLint
- Prettier
- Java Extension Pack
- Spring Boot Extension Pack

**권장:**
- Tailwind CSS IntelliSense
- GitLens
- Thunder Client (API 테스트)
- Docker

### 10.4 환경 변수 설정

**.env 파일 (프로젝트 루트):**

```env
# MySQL
MYSQL_ROOT_PASSWORD=root
MYSQL_DATABASE=taskflow
MYSQL_USER=taskflow
MYSQL_PASSWORD=taskflow123

# Backend
SPRING_PROFILES_ACTIVE=docker
JWT_SECRET=your-secret-key-must-be-at-least-256-bits-long

# Frontend
VITE_API_BASE_URL=http://localhost:8080
```

### 10.5 데이터베이스 초기화

```bash
# MySQL 컨테이너 접속
docker exec -it taskflow-mysql mysql -u root -p

# 스키마 확인
USE taskflow;
SHOW TABLES;

# 초기 데이터 확인
SELECT * FROM TB_USER;
```

---

## 11. 빌드 및 배포

### 11.1 개발 빌드

```bash
# Backend 빌드
cd backend
./gradlew build -x test

# Frontend 빌드
cd frontend
npm run build
```

### 11.2 Docker 이미지 빌드

```bash
# 전체 빌드 및 실행
docker compose up -d --build

# 개별 이미지 빌드
docker compose build backend
docker compose build frontend
```

### 11.3 배포 스크립트 실행

**Linux/Mac:**

```bash
# 배포 스크립트 실행
chmod +x build-release.sh
./build-release.sh 2.0.0

# 결과 확인
ls -la dist/
```

**Windows (PowerShell):**

```powershell
# 배포 스크립트 실행
.\build-release.ps1 -Version 2.0.0

# 결과 확인
Get-ChildItem .\dist\
```

### 11.4 배포 아티팩트

```
dist/
├── taskflow-2.0.0/
│   ├── backend/
│   │   ├── src/
│   │   ├── gradle/
│   │   ├── build.gradle.kts
│   │   ├── settings.gradle.kts
│   │   ├── gradlew
│   │   ├── gradlew.bat
│   │   └── Dockerfile
│   ├── frontend/
│   │   ├── src/
│   │   ├── dist/             # 빌드된 파일
│   │   ├── package.json
│   │   ├── vite.config.ts
│   │   ├── nginx.conf
│   │   └── Dockerfile
│   ├── docker/
│   │   └── mysql/
│   │       └── init/
│   │           └── 01_schema.sql
│   ├── docker-compose.yml
│   └── .env.example
└── taskflow-2.0.0.tar.gz      # 압축 파일
```

### 11.5 서버 배포

```bash
# 1. 압축 파일 전송
scp dist/taskflow-2.0.0.tar.gz user@server:/app/

# 2. 서버에서 압축 해제
ssh user@server
cd /app
tar -xzvf taskflow-2.0.0.tar.gz
cd taskflow-2.0.0

# 3. 환경 변수 설정
cp .env.example .env
vi .env

# 4. Docker Compose 실행
docker compose up -d --build

# 5. 상태 확인
docker compose ps
docker compose logs -f
```

---

## 12. 코딩 컨벤션

### 12.1 Java 코딩 컨벤션

**네이밍:**
- 클래스: `PascalCase` (예: `ItemController`, `UserService`)
- 메서드/변수: `camelCase` (예: `getItems`, `boardId`)
- 상수: `UPPER_SNAKE_CASE` (예: `DEFAULT_TIMEOUT`)
- 패키지: `lowercase` (예: `com.taskflow.service`)

**어노테이션 순서:**
```java
@RestController
@RequestMapping("/api/items")
@RequiredArgsConstructor
@Slf4j
public class ItemController {
    // ...
}
```

**메서드 순서:**
1. 생성자
2. Public 메서드
3. Protected 메서드
4. Private 메서드

### 12.2 TypeScript/Vue 코딩 컨벤션

**네이밍:**
- 컴포넌트: `PascalCase` (예: `ItemList.vue`, `UserForm.vue`)
- Composable: `camelCase` + use 접두사 (예: `useAuth.ts`, `useToast.ts`)
- 타입/인터페이스: `PascalCase` (예: `Item`, `ItemCreateRequest`)
- 상수: `UPPER_SNAKE_CASE` 또는 `camelCase`

**import 순서:**
```typescript
// 1. Vue 관련
import { ref, computed, onMounted } from 'vue'

// 2. 외부 라이브러리
import { storeToRefs } from 'pinia'

// 3. 내부 모듈 - Store
import { useItemStore } from '@/stores/item'

// 4. 내부 모듈 - Composable
import { useToast } from '@/composables/useToast'

// 5. 내부 모듈 - API
import { itemApi } from '@/api/item'

// 6. 내부 모듈 - Type
import type { Item } from '@/types/item'

// 7. 내부 모듈 - Component
import ItemRow from '@/components/item/ItemRow.vue'
```

### 12.3 SQL 코딩 컨벤션

**테이블/컬럼:**
- 테이블: `TB_` 접두사 + `UPPER_SNAKE_CASE` (예: `TB_ITEM`, `TB_USER`)
- 컬럼: `UPPER_SNAKE_CASE` (예: `ITEM_ID`, `CREATED_AT`)
- PK: `테이블명_ID` (예: `USER_ID`, `BOARD_ID`)

**SQL 작성:**
```sql
SELECT
    i.ITEM_ID,
    i.CONTENT,
    i.STATUS,
    u.NAME AS ASSIGNEE_NAME
FROM TB_ITEM i
LEFT JOIN TB_USER u ON i.ASSIGNEE_ID = u.USER_ID
WHERE i.BOARD_ID = #{boardId}
    AND i.STATUS != 'DELETED'
ORDER BY i.CREATED_AT DESC
LIMIT #{offset}, #{size}
```

### 12.4 Git 컨벤션

**브랜치 전략:**
```
main          # 프로덕션
├── develop   # 개발 통합
│   ├── feature/add-kanban-view
│   ├── feature/user-management
│   └── bugfix/login-error
└── hotfix/critical-fix
```

**커밋 메시지:**
```
feat: 칸반 뷰 추가
fix: 로그인 오류 수정
docs: README 업데이트
style: 코드 포맷팅
refactor: 서비스 레이어 리팩토링
test: 단위 테스트 추가
chore: 빌드 설정 변경
```

---

## 13. 트러블슈팅

### 13.1 빌드 오류

#### Gradle 빌드 실패

```bash
# 캐시 클리어
./gradlew clean build --refresh-dependencies

# Gradle 버전 확인
./gradlew --version
```

#### npm 빌드 실패

```bash
# node_modules 삭제 후 재설치
rm -rf node_modules package-lock.json
npm install

# 캐시 클리어
npm cache clean --force
```

### 13.2 런타임 오류

#### MySQL 연결 실패

```bash
# MySQL 컨테이너 상태 확인
docker compose ps

# MySQL 로그 확인
docker compose logs mysql

# 연결 테스트
docker exec -it taskflow-mysql mysql -u taskflow -p -e "SELECT 1"
```

#### JWT 토큰 오류

```
# application.yml 확인
jwt:
  secret: ${JWT_SECRET:...}  # 최소 256비트 (32자 이상)
  access-token-validity: 1800000
  refresh-token-validity: 604800000
```

### 13.3 SSE 연결 문제

#### Nginx 프록시 설정

```nginx
# SSE를 위한 프록시 설정
location /api/sse/ {
    proxy_pass http://backend:8080;
    proxy_http_version 1.1;
    proxy_set_header Connection '';
    proxy_buffering off;
    proxy_cache off;
    chunked_transfer_encoding off;
    proxy_read_timeout 3600s;
}
```

### 13.4 성능 문제

#### MyBatis 쿼리 로깅

```yaml
# application.yml
logging:
  level:
    com.taskflow.mapper: DEBUG
```

#### 슬로우 쿼리 확인

```sql
-- MySQL 슬로우 쿼리 로그 활성화
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 1;

-- 슬로우 쿼리 확인
SHOW FULL PROCESSLIST;
```

---

## 부록

### A. API 엔드포인트 목록

| 메서드 | 엔드포인트 | 설명 |
|--------|-----------|------|
| POST | /api/auth/login | 로그인 |
| POST | /api/auth/logout | 로그아웃 |
| POST | /api/auth/refresh | 토큰 갱신 |
| GET | /api/users | 사용자 목록 |
| POST | /api/users | 사용자 등록 |
| GET | /api/departments | 부서 목록 (트리) |
| GET | /api/groups | 그룹 목록 |
| GET | /api/boards | 보드 목록 |
| POST | /api/boards | 보드 생성 |
| GET | /api/boards/{id}/items | 업무 목록 |
| POST | /api/boards/{id}/items | 업무 생성 |
| GET | /api/sse/subscribe | SSE 구독 |

자세한 API 명세는 [02_API_명세서.md](./02_API_명세서.md)를 참조하세요.

### B. 데이터베이스 스키마

전체 스키마는 `docker/mysql/init/01_schema.sql` 파일을 참조하세요.

### C. 참고 자료

- [Spring Boot 공식 문서](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [MyBatis 공식 문서](https://mybatis.org/mybatis-3/)
- [Vue.js 공식 문서](https://vuejs.org/)
- [Pinia 공식 문서](https://pinia.vuejs.org/)
- [Tailwind CSS 공식 문서](https://tailwindcss.com/docs)

---

**문서 버전**: 2.0.0
**최종 수정일**: 2024년 12월
**작성자**: TaskFlow Development Team
