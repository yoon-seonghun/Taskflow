# TaskFlow 2.0 배포 가이드

## 목차

1. [시스템 요구사항](#1-시스템-요구사항)
2. [배포 준비](#2-배포-준비)
3. [환경 설정](#3-환경-설정)
4. [Docker 배포](#4-docker-배포)
5. [초기 설정](#5-초기-설정)
6. [운영 관리](#6-운영-관리)
7. [문제 해결](#7-문제-해결)
8. [보안 권장사항](#8-보안-권장사항)

---

## 1. 시스템 요구사항

### 1.1 하드웨어 요구사항

| 구분 | 최소 사양 | 권장 사양 | 비고 |
|------|----------|----------|------|
| CPU | 2 Core | 4 Core 이상 | x86_64 아키텍처 |
| RAM | 4GB | 8GB 이상 | 동시 사용자 수에 따라 증가 |
| Storage | 10GB | 20GB 이상 | SSD 권장 |
| Network | 100Mbps | 1Gbps | 안정적인 네트워크 연결 |

**용량 상세:**
- MySQL 데이터베이스: 최소 2GB (데이터 증가에 따라 확장)
- Backend 컨테이너: 약 500MB
- Frontend 컨테이너: 약 200MB
- Docker 이미지 캐시: 약 1-2GB
- 로그 및 임시 파일: 1GB

### 1.2 소프트웨어 요구사항

| 소프트웨어 | 최소 버전 | 권장 버전 | 확인 명령어 |
|-----------|----------|----------|------------|
| OS | Linux, Windows 10+, macOS 10.14+ | Ubuntu 22.04 LTS | `uname -a` |
| Docker | 20.10.0 | 24.0.0 이상 | `docker --version` |
| Docker Compose | 2.0.0 | 2.20.0 이상 | `docker compose version` |

**지원 운영체제:**
- Linux: Ubuntu 20.04+, CentOS 8+, Debian 11+
- Windows: Windows 10/11 (WSL2 또는 Docker Desktop)
- macOS: macOS 10.14 이상

**Docker 설치 확인:**
```bash
# Docker 버전 확인
docker --version
# 예: Docker version 24.0.7, build afdd53b

# Docker Compose 버전 확인
docker compose version
# 예: Docker Compose version v2.23.0

# Docker 실행 권한 확인
docker ps
# 오류 없이 실행되어야 함
```

### 1.3 네트워크 요구사항

**필수 포트:**

| 포트 | 서비스 | 프로토콜 | 설명 |
|------|--------|---------|------|
| 3000 | Frontend | TCP | 웹 UI 접속 (변경 가능) |
| 8080 | Backend | TCP | API 서버 (변경 가능) |
| 3306 | MySQL | TCP | 데이터베이스 (변경 가능) |

**방화벽 설정 (Linux 예시):**
```bash
# Frontend 포트 허용
sudo ufw allow 3000/tcp

# 외부 접속을 허용하지 않을 포트 (내부용)
# MySQL: 3306 - Docker 네트워크 내부에서만 접근
# Backend: 8080 - Nginx 프록시를 통해서만 접근 (직접 접근 차단 권장)
```

**네트워크 요구사항:**
- 인터넷 연결: Docker 이미지 다운로드 시 필요
- 방화벽: 필요한 포트만 개방
- DNS: 정상 동작 필요

---

## 2. 배포 준비

### 2.1 배포본 생성 (개발 환경에서)

#### Linux/macOS에서 배포본 생성

```bash
# 프로젝트 루트 디렉토리로 이동
cd /path/to/Taskflow

# 배포본 생성 스크립트 실행
chmod +x build-release.sh
./build-release.sh

# 생성된 파일 확인
ls -lh dist/
# taskflow-1.0.0.tar.gz  (약 50-100MB)
```

#### Windows에서 배포본 생성

```powershell
# 프로젝트 루트 디렉토리로 이동
cd C:\path\to\Taskflow

# 배포본 생성 스크립트 실행
.\build-release.ps1

# 생성된 파일 확인
dir dist\
# taskflow-1.0.0.zip  (약 50-100MB)
```

### 2.2 배포본 다운로드/전송

**방법 1: SCP로 전송 (Linux/macOS → 서버)**
```bash
# 압축 파일 전송
scp dist/taskflow-1.0.0.tar.gz user@server-ip:/home/user/

# 또는 디렉토리 전체 전송
scp -r dist/taskflow-1.0.0 user@server-ip:/home/user/
```

**방법 2: SFTP 사용**
```bash
sftp user@server-ip
put dist/taskflow-1.0.0.tar.gz
quit
```

**방법 3: USB/공유 폴더**
- 네트워크 접근이 제한된 환경에서 USB 드라이브 사용
- 공유 폴더를 통한 파일 복사

### 2.3 압축 해제

#### Linux/macOS
```bash
# 배포 디렉토리 생성
mkdir -p /opt/taskflow
cd /opt/taskflow

# tar.gz 압축 해제
tar -xzvf /path/to/taskflow-1.0.0.tar.gz

# 디렉토리 이동
cd taskflow-1.0.0
```

#### Windows (PowerShell)
```powershell
# 배포 디렉토리 생성
New-Item -Path "C:\taskflow" -ItemType Directory -Force
cd C:\taskflow

# ZIP 압축 해제
Expand-Archive -Path "C:\path\to\taskflow-1.0.0.zip" -DestinationPath .

# 디렉토리 이동
cd taskflow-1.0.0
```

### 2.4 디렉토리 구조 확인

```bash
# 디렉토리 구조 확인
tree -L 2

# 또는
ls -la
```

**기대 구조:**
```
taskflow-1.0.0/
├── backend/                    # Spring Boot 백엔드
│   ├── src/                   # 소스 코드
│   ├── build.gradle.kts       # Gradle 빌드 설정
│   ├── settings.gradle.kts
│   ├── gradlew                # Gradle Wrapper (Linux/Mac)
│   ├── gradlew.bat            # Gradle Wrapper (Windows)
│   └── Dockerfile             # Backend 도커 이미지 빌드
├── frontend/                   # Vue.js 프론트엔드
│   ├── src/                   # 소스 코드
│   ├── dist/                  # 빌드된 정적 파일
│   ├── package.json           # NPM 의존성
│   ├── vite.config.ts         # Vite 설정
│   ├── nginx.conf             # Nginx 설정
│   └── Dockerfile             # Frontend 도커 이미지 빌드
├── docker/                     # Docker 관련 설정
│   └── mysql/
│       └── init/              # MySQL 초기화 스크립트
│           ├── 01_schema.sql  # 스키마 생성
│           └── 02_init_data.sql # 초기 데이터
├── scripts/                    # 운영 스크립트
│   ├── start.sh / start.bat   # 서비스 시작
│   └── stop.sh / stop.bat     # 서비스 중지
├── docker-compose.yml          # Docker Compose 설정
├── .env.example                # 환경변수 템플릿
└── DEPLOYMENT.md               # 배포 가이드
```

---

## 3. 환경 설정

### 3.1 .env 파일 생성

```bash
# .env.example을 복사하여 .env 파일 생성
cp .env.example .env

# 편집기로 열기
nano .env          # Linux
vi .env            # Linux (vi 사용자)
notepad .env       # Windows
code .env          # VS Code 사용자
```

### 3.2 환경 변수 상세 설명

#### 데이터베이스 설정

```env
# ============================================
# MySQL Database
# ============================================
MYSQL_ROOT_PASSWORD=root
MYSQL_DATABASE=taskflow
MYSQL_USER=taskflow
MYSQL_PASSWORD=taskflow123
```

**설명:**
- `MYSQL_ROOT_PASSWORD`: MySQL root 계정 비밀번호
  - 기본값: `root`
  - 프로덕션: 강력한 비밀번호로 변경 필수 (최소 16자, 대소문자+숫자+특수문자)
- `MYSQL_DATABASE`: 생성할 데이터베이스 이름
  - 기본값: `taskflow`
  - 변경 시 Backend 설정도 함께 변경 필요
- `MYSQL_USER`: 애플리케이션용 DB 사용자
  - 기본값: `taskflow`
  - root가 아닌 별도 사용자 권장
- `MYSQL_PASSWORD`: DB 사용자 비밀번호
  - 기본값: `taskflow123`
  - 프로덕션: 강력한 비밀번호로 변경 필수

#### JWT 인증 설정 (필수)

```env
# ============================================
# JWT Authentication (필수 - 반드시 변경하세요!)
# ============================================
JWT_SECRET=your-base64-encoded-secret-key-at-least-256-bits-long
```

**설명:**
- `JWT_SECRET`: JWT 토큰 서명에 사용되는 비밀 키
  - 반드시 변경 필수 (보안상 매우 중요)
  - Base64 인코딩된 256비트 이상의 랜덤 문자열
  - 유출 시 모든 JWT 토큰이 위조 가능하므로 안전하게 관리

### 3.3 JWT_SECRET 생성 방법

#### Linux/macOS
```bash
# OpenSSL 사용 (권장)
openssl rand -base64 32

# 출력 예시:
# mK7pQ9vR2nL8xT4wY6zC1bN5aM3dF0gH8jS4kL6pO9qE=

# 생성된 값을 .env 파일에 복사
```

#### Windows (PowerShell)
```powershell
# PowerShell에서 랜덤 키 생성
$bytes = New-Object Byte[] 32
[Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($bytes)
[Convert]::ToBase64String($bytes)

# 출력된 값을 .env 파일에 복사
```

#### 온라인 도구 (권장하지 않음)
- 온라인 Base64 생성기 사용 가능하나 보안상 로컬 생성 권장
- 사용 시 신뢰할 수 있는 사이트에서만 사용

**적용 예시:**
```env
JWT_SECRET=mK7pQ9vR2nL8xT4wY6zC1bN5aM3dF0gH8jS4kL6pO9qE=
```

#### 포트 설정 (선택)

```env
# ============================================
# Server Ports (선택)
# ============================================
MYSQL_PORT=3306
BACKEND_PORT=8080
FRONTEND_PORT=3000
```

**설명:**
- `MYSQL_PORT`: MySQL 외부 노출 포트 (기본: 3306)
  - 변경 이유: 포트 충돌 방지, 보안
  - 예: 13306, 33060
- `BACKEND_PORT`: Backend API 외부 노출 포트 (기본: 8080)
  - 변경 이유: 포트 충돌 방지
  - 예: 18080, 8081
- `FRONTEND_PORT`: Frontend 웹 UI 포트 (기본: 3000)
  - 사용자가 접속하는 포트
  - 변경 시 CORS 설정도 함께 변경 필수!

**포트 충돌 확인:**
```bash
# Linux/macOS
lsof -i :3000
lsof -i :8080
lsof -i :3306

# Windows (PowerShell)
netstat -ano | findstr :3000
netstat -ano | findstr :8080
netstat -ano | findstr :3306
```

#### CORS 설정 (중요!)

```env
# ============================================
# CORS Settings (중요!)
# ============================================
CORS_ALLOWED_ORIGINS=http://localhost:3000
```

**설명:**
- `CORS_ALLOWED_ORIGINS`: 허용할 프론트엔드 주소
  - Frontend 접속 URL과 정확히 일치해야 함
  - 프로토콜(http/https), 호스트, 포트 모두 포함
  - 여러 origin 허용 시 쉼표로 구분

**시나리오별 설정 예시:**

1. **기본 설정 (localhost:3000)**
   ```env
   FRONTEND_PORT=3000
   CORS_ALLOWED_ORIGINS=http://localhost:3000
   ```

2. **포트 변경 (localhost:4000)**
   ```env
   FRONTEND_PORT=4000
   CORS_ALLOWED_ORIGINS=http://localhost:4000
   ```

3. **외부 도메인 사용**
   ```env
   FRONTEND_PORT=80
   CORS_ALLOWED_ORIGINS=https://taskflow.example.com
   ```

4. **여러 Origin 허용**
   ```env
   CORS_ALLOWED_ORIGINS=http://localhost:3000,https://taskflow.example.com
   ```

5. **IP 주소 사용**
   ```env
   CORS_ALLOWED_ORIGINS=http://192.168.1.100:3000
   ```

#### Cookie 설정 (선택)

```env
# ============================================
# Cookie Settings (선택)
# ============================================
COOKIE_SECURE=false
```

**설명:**
- `COOKIE_SECURE`: HTTPS 환경에서만 쿠키 전송 여부
  - `false`: HTTP/HTTPS 모두 허용 (개발/테스트)
  - `true`: HTTPS만 허용 (프로덕션 권장)
  - HTTPS 사용 시 반드시 `true`로 설정

#### 시간대 설정

```env
# ============================================
# Timezone
# ============================================
TZ=Asia/Seoul
```

**설명:**
- `TZ`: 서버 시간대 설정
  - 기본값: `Asia/Seoul` (한국 표준시)
  - 다른 시간대: `America/New_York`, `Europe/London` 등

### 3.4 설정 파일 예시

#### 개발/테스트 환경
```env
# 개발 환경 설정
MYSQL_ROOT_PASSWORD=root
MYSQL_DATABASE=taskflow
MYSQL_USER=taskflow
MYSQL_PASSWORD=taskflow123

JWT_SECRET=mK7pQ9vR2nL8xT4wY6zC1bN5aM3dF0gH8jS4kL6pO9qE=

MYSQL_PORT=3306
BACKEND_PORT=8080
FRONTEND_PORT=3000

CORS_ALLOWED_ORIGINS=http://localhost:3000
COOKIE_SECURE=false

TZ=Asia/Seoul
```

#### 프로덕션 환경
```env
# 프로덕션 환경 설정
MYSQL_ROOT_PASSWORD=Str0ng!Root@P@ssw0rd#2024
MYSQL_DATABASE=taskflow
MYSQL_USER=taskflow_prod
MYSQL_PASSWORD=Pr0d!T@skfl0w#DB@2024

JWT_SECRET=aB3dE6gH9jK2mN5pQ8sT1vW4yZ7cF0iL3nO6qR9tU2xA5bD8eG1hJ4kM7oP0rS3u=

MYSQL_PORT=13306
BACKEND_PORT=18080
FRONTEND_PORT=443

CORS_ALLOWED_ORIGINS=https://taskflow.company.com
COOKIE_SECURE=true

TZ=Asia/Seoul
```

---

## 4. Docker 배포

### 4.1 서비스 시작

#### 방법 1: 스크립트 사용 (권장)

```bash
# Linux/macOS
chmod +x scripts/start.sh
./scripts/start.sh

# Windows
scripts\start.bat
```

#### 방법 2: Docker Compose 직접 실행

```bash
# 백그라운드로 시작 (빌드 포함)
docker compose up -d --build

# 로그 출력하며 시작 (디버깅용)
docker compose up --build
```

**예상 출력:**
```
[+] Building 125.3s (23/23) FINISHED
[+] Running 4/4
 ✔ Network taskflow_taskflow-network    Created
 ✔ Container taskflow-mysql             Started
 ✔ Container taskflow-backend           Started
 ✔ Container taskflow-frontend          Started
```

### 4.2 컨테이너 상태 확인

```bash
# 컨테이너 상태 확인
docker compose ps
```

**정상 출력 예시:**
```
NAME                 IMAGE              STATUS          PORTS
taskflow-backend     taskflow-backend   Up 2 minutes    0.0.0.0:8080->8080/tcp
taskflow-frontend    taskflow-frontend  Up 2 minutes    0.0.0.0:3000->80/tcp
taskflow-mysql       mysql:8.0          Up 2 minutes    0.0.0.0:3306->3306/tcp, 33060/tcp
```

**상태별 의미:**
- `Up`: 정상 실행 중
- `Up (healthy)`: 헬스체크 통과
- `Restarting`: 재시작 중 (문제 발생 가능성)
- `Exited`: 종료됨 (오류 확인 필요)

### 4.3 로그 확인 방법

#### 전체 로그 확인
```bash
# 모든 서비스 로그 실시간 확인
docker compose logs -f

# 최근 100줄만 확인
docker compose logs --tail=100
```

#### 서비스별 로그 확인
```bash
# Backend 로그
docker compose logs -f backend

# Frontend 로그
docker compose logs -f frontend

# MySQL 로그
docker compose logs -f mysql
```

#### 특정 시간대 로그
```bash
# 최근 10분간 로그
docker compose logs --since 10m

# 특정 시간 이후 로그
docker compose logs --since "2024-12-24T10:00:00"
```

### 4.4 서비스 접속 확인

#### 웹 브라우저 접속
```
http://localhost:3000
또는
http://서버IP:3000
```

#### API 헬스체크
```bash
# Backend API 상태 확인
curl http://localhost:8080/api/health

# 또는
curl http://localhost:8080/actuator/health
```

#### MySQL 연결 확인
```bash
# MySQL 클라이언트 연결
docker compose exec mysql mysql -u taskflow -p taskflow

# 비밀번호 입력: .env의 MYSQL_PASSWORD 값
```

### 4.5 빌드 단계별 진행 상황

**1단계: MySQL 컨테이너 시작 (10-30초)**
- MySQL 이미지 다운로드 (최초 1회)
- 컨테이너 생성 및 시작
- 데이터베이스 초기화 스크립트 실행

**2단계: Backend 빌드 및 시작 (2-5분)**
- Gradle 의존성 다운로드
- Spring Boot 애플리케이션 빌드
- JAR 파일 생성
- 컨테이너 시작 및 MySQL 연결 대기

**3단계: Frontend 빌드 및 시작 (1-3분)**
- Node.js 의존성 다운로드
- Vue 애플리케이션 빌드
- Nginx 컨테이너 시작

**전체 소요 시간:**
- 최초 빌드: 약 5-10분
- 재시작 (캐시 있음): 약 30초-1분

---

## 5. 초기 설정

### 5.1 관리자 계정

**기본 관리자 계정:**
- 아이디: `admin`
- 비밀번호: `admin1234`

### 5.2 초기 로그인

1. 웹 브라우저에서 접속: `http://localhost:3000`
2. 로그인 페이지에서 관리자 계정으로 로그인
3. 최초 로그인 성공 확인

### 5.3 초기 비밀번호 변경 (필수)

**보안을 위해 관리자 비밀번호를 즉시 변경하세요!**

1. 로그인 후 우측 상단 프로필 클릭
2. "설정" 또는 "내 정보" 메뉴 선택
3. 비밀번호 변경 섹션에서 변경
4. 새 비밀번호 요구사항:
   - 최소 8자 이상
   - 영문 대문자 1개 이상
   - 영문 소문자 1개 이상
   - 숫자 1개 이상
   - 특수문자 1개 이상 (!@#$%^&*)

### 5.4 기본 데이터 확인

초기 데이터베이스에 생성되는 기본 데이터:

**1. 사용자 계정:**
- 관리자: admin (admin1234)
- 테스트 사용자: user1, user2, user3

**2. 부서:**
- 경영지원본부
  - 인사팀
  - 총무팀
  - 재무팀
- 개발본부
  - 개발1팀
  - 개발2팀

**3. 코드 항목:**
- 상태: 시작전, 진행중, 완료, 삭제
- 우선순위: 긴급, 높음, 보통, 낮음

**4. 샘플 보드 및 업무:**
- "팀 프로젝트" 보드
- 샘플 업무 아이템 3개

### 5.5 초기 설정 확인 체크리스트

- [ ] 웹 UI 정상 접속 확인
- [ ] 관리자 계정 로그인 성공
- [ ] 관리자 비밀번호 변경
- [ ] 부서 목록 조회 확인
- [ ] 그룹 목록 조회 확인
- [ ] 샘플 보드 및 업무 확인
- [ ] 신규 업무 등록 테스트
- [ ] 업무 수정/삭제 테스트

---

## 6. 운영 관리

### 6.1 서비스 시작/중지/재시작

#### 서비스 시작
```bash
# 스크립트 사용
./scripts/start.sh          # Linux/macOS
scripts\start.bat           # Windows

# Docker Compose 직접 사용
docker compose up -d

# 특정 서비스만 시작
docker compose up -d backend
```

#### 서비스 중지
```bash
# 스크립트 사용
./scripts/stop.sh           # Linux/macOS
scripts\stop.bat            # Windows

# Docker Compose 직접 사용
docker compose down

# 컨테이너만 중지 (볼륨 유지)
docker compose stop
```

#### 서비스 재시작
```bash
# 전체 재시작
docker compose restart

# 특정 서비스만 재시작
docker compose restart backend
docker compose restart frontend
docker compose restart mysql

# 재시작 (재빌드 포함)
docker compose up -d --build
```

#### 서비스 일시 정지/재개
```bash
# 일시 정지
docker compose pause

# 재개
docker compose unpause
```

### 6.2 로그 모니터링

#### 실시간 로그 모니터링
```bash
# 전체 서비스 로그 (Ctrl+C로 종료)
docker compose logs -f

# 특정 서비스 로그
docker compose logs -f backend
docker compose logs -f frontend
docker compose logs -f mysql

# 여러 서비스 동시 모니터링
docker compose logs -f backend frontend
```

#### 로그 필터링
```bash
# 최근 100줄만 출력
docker compose logs --tail=100 backend

# 특정 키워드 검색
docker compose logs backend | grep ERROR
docker compose logs backend | grep "Exception"

# 타임스탬프 포함
docker compose logs -t backend
```

#### 로그 파일로 저장
```bash
# 전체 로그 저장
docker compose logs > taskflow-logs-$(date +%Y%m%d).log

# 특정 서비스 로그 저장
docker compose logs backend > backend-$(date +%Y%m%d).log
```

### 6.3 백업 및 복원

#### 데이터베이스 백업

**방법 1: mysqldump 사용 (권장)**
```bash
# 백업 디렉토리 생성
mkdir -p backups

# 전체 데이터베이스 백업
docker compose exec mysql mysqldump \
  -u taskflow \
  -p taskflow \
  > backups/taskflow-backup-$(date +%Y%m%d-%H%M%S).sql

# 비밀번호 입력: .env의 MYSQL_PASSWORD 값

# 백업 파일 압축
gzip backups/taskflow-backup-*.sql
```

**방법 2: Docker Volume 백업**
```bash
# MySQL 데이터 볼륨 백업
docker run --rm \
  -v taskflow_mysql_data:/data \
  -v $(pwd)/backups:/backup \
  alpine tar czf /backup/mysql-volume-$(date +%Y%m%d).tar.gz /data
```

#### 자동 백업 스크립트 (Linux/macOS)

`backups/auto-backup.sh` 파일 생성:
```bash
#!/bin/bash

BACKUP_DIR="/opt/taskflow/backups"
DATE=$(date +%Y%m%d-%H%M%S)
BACKUP_FILE="$BACKUP_DIR/taskflow-$DATE.sql"
KEEP_DAYS=30

# 백업 디렉토리 생성
mkdir -p "$BACKUP_DIR"

# 데이터베이스 백업
docker compose exec -T mysql mysqldump \
  -u taskflow \
  -ptaskflow123 \
  taskflow > "$BACKUP_FILE"

# 압축
gzip "$BACKUP_FILE"

# 30일 이상 된 백업 삭제
find "$BACKUP_DIR" -name "taskflow-*.sql.gz" -mtime +$KEEP_DAYS -delete

echo "Backup completed: $BACKUP_FILE.gz"
```

**Cron 등록 (매일 새벽 2시 자동 백업):**
```bash
# crontab 편집
crontab -e

# 추가
0 2 * * * /opt/taskflow/backups/auto-backup.sh >> /var/log/taskflow-backup.log 2>&1
```

#### 데이터베이스 복원

**방법 1: SQL 파일에서 복원**
```bash
# 압축 해제
gunzip backups/taskflow-backup-20241224-120000.sql.gz

# 복원 (주의: 기존 데이터 삭제됨!)
docker compose exec -T mysql mysql \
  -u taskflow \
  -p taskflow \
  < backups/taskflow-backup-20241224-120000.sql

# 비밀번호 입력
```

**방법 2: 볼륨에서 복원**
```bash
# 1. 서비스 중지
docker compose down

# 2. 기존 볼륨 삭제
docker volume rm taskflow_mysql_data

# 3. 볼륨 복원
docker run --rm \
  -v taskflow_mysql_data:/data \
  -v $(pwd)/backups:/backup \
  alpine tar xzf /backup/mysql-volume-20241224.tar.gz -C /

# 4. 서비스 재시작
docker compose up -d
```

#### 파일 업로드 백업

```bash
# 업로드 파일 볼륨 백업
docker run --rm \
  -v taskflow_file_uploads:/data \
  -v $(pwd)/backups:/backup \
  alpine tar czf /backup/uploads-$(date +%Y%m%d).tar.gz /data
```

### 6.4 업데이트 절차

#### 애플리케이션 업데이트

**1단계: 백업**
```bash
# 데이터베이스 백업
./backups/auto-backup.sh

# 또는 수동 백업
docker compose exec mysql mysqldump -u taskflow -p taskflow > backup-before-update.sql
```

**2단계: 새 버전 다운로드**
```bash
# 새 배포본 다운로드 및 압축 해제
tar -xzvf taskflow-2.0.0.tar.gz
cd taskflow-2.0.0
```

**3단계: 환경 설정 마이그레이션**
```bash
# 기존 .env 파일 복사
cp /opt/taskflow/taskflow-1.0.0/.env .env

# 새 버전의 .env.example과 비교하여 누락된 설정 추가
diff .env .env.example
```

**4단계: 서비스 업데이트**
```bash
# 기존 서비스 중지
cd /opt/taskflow/taskflow-1.0.0
docker compose down

# 새 버전으로 이동
cd /opt/taskflow/taskflow-2.0.0

# 서비스 시작 (재빌드)
docker compose up -d --build
```

**5단계: 업데이트 확인**
```bash
# 로그 확인
docker compose logs -f

# 웹 UI 접속 확인
curl http://localhost:3000

# 데이터 정합성 확인
```

**롤백 (문제 발생 시)**
```bash
# 새 버전 중지
cd /opt/taskflow/taskflow-2.0.0
docker compose down

# 이전 버전으로 복귀
cd /opt/taskflow/taskflow-1.0.0
docker compose up -d

# 백업에서 데이터 복원 (필요시)
docker compose exec -T mysql mysql -u taskflow -p taskflow < backup-before-update.sql
```

### 6.5 리소스 모니터링

#### 컨테이너 리소스 사용량
```bash
# 실시간 리소스 모니터링
docker stats

# 특정 컨테이너만 모니터링
docker stats taskflow-backend taskflow-mysql

# 1회만 출력
docker stats --no-stream
```

**출력 예시:**
```
CONTAINER ID   NAME               CPU %   MEM USAGE / LIMIT   MEM %   NET I/O
abc123         taskflow-backend   5.2%    512MiB / 8GiB       6.4%    1.2MB / 850kB
def456         taskflow-mysql     2.1%    1.5GiB / 8GiB      18.7%    850kB / 1.2MB
ghi789         taskflow-frontend  0.1%    50MiB / 8GiB        0.6%    200kB / 300kB
```

#### 디스크 사용량
```bash
# Docker 전체 디스크 사용량
docker system df

# 상세 정보
docker system df -v

# 볼륨 사용량 확인
docker volume ls
docker volume inspect taskflow_mysql_data
```

#### 로그 파일 크기 관리
```bash
# 로그 파일 크기 확인
docker compose exec backend du -sh /var/log

# 오래된 로그 삭제 (컨테이너 내부)
docker compose exec backend find /var/log -name "*.log" -mtime +30 -delete
```

#### 리소스 제한 설정

`docker-compose.yml`에 리소스 제한 추가:
```yaml
services:
  backend:
    # ... 기존 설정 ...
    deploy:
      resources:
        limits:
          cpus: '2.0'      # 최대 2 CPU
          memory: 2G       # 최대 2GB RAM
        reservations:
          cpus: '1.0'      # 최소 1 CPU
          memory: 1G       # 최소 1GB RAM

  mysql:
    # ... 기존 설정 ...
    deploy:
      resources:
        limits:
          cpus: '2.0'
          memory: 4G
        reservations:
          cpus: '1.0'
          memory: 2G
```

### 6.6 로그 로테이션 설정

`/etc/docker/daemon.json` 설정:
```json
{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
```

적용:
```bash
sudo systemctl restart docker
docker compose restart
```

---

## 7. 문제 해결

### 7.1 MySQL 연결 실패

**증상:**
- Backend 컨테이너가 계속 재시작됨
- 로그에 `Cannot connect to MySQL` 오류 표시

**원인:**
1. MySQL이 완전히 시작되지 않음 (초기화 중)
2. 환경변수 설정 오류
3. 네트워크 문제

**해결 방법:**

```bash
# 1. MySQL 컨테이너 상태 확인
docker compose ps mysql
# STATUS가 "Up (healthy)"인지 확인

# 2. MySQL 로그 확인
docker compose logs mysql
# "ready for connections" 메시지 확인

# 3. MySQL이 아직 시작 중이면 대기 (보통 30초~1분)
docker compose logs -f mysql

# 4. 환경변수 확인
docker compose exec backend env | grep MYSQL
# SPRING_DATASOURCE_URL, USERNAME, PASSWORD 확인

# 5. MySQL 직접 연결 테스트
docker compose exec mysql mysql -u taskflow -p
# 비밀번호 입력 후 연결 확인

# 6. 네트워크 연결 테스트
docker compose exec backend ping mysql
docker compose exec backend nc -zv mysql 3306

# 7. Backend 재시작
docker compose restart backend
```

### 7.2 포트 충돌

**증상:**
```
Error: bind: address already in use
또는
port is already allocated
```

**원인:**
- 다른 프로세스가 이미 해당 포트 사용 중

**해결 방법:**

```bash
# 1. 사용 중인 포트 확인
# Linux/macOS
lsof -i :3000
lsof -i :8080
lsof -i :3306

# Windows (PowerShell)
netstat -ano | findstr :3000
netstat -ano | findstr :8080
netstat -ano | findstr :3306

# 2. 프로세스 종료 (Linux/macOS)
# PID 확인 후
kill -9 <PID>

# Windows
# PID 확인 후
taskkill /PID <PID> /F

# 3. 또는 .env에서 포트 변경
nano .env
```

**.env 포트 변경 예시:**
```env
MYSQL_PORT=13306
BACKEND_PORT=18080
FRONTEND_PORT=13000

# CORS도 함께 변경!
CORS_ALLOWED_ORIGINS=http://localhost:13000
```

```bash
# 4. 서비스 재시작
docker compose down
docker compose up -d --build
```

### 7.3 CORS 에러

**증상:**
- 브라우저 개발자 도구 콘솔에 CORS 오류 표시
- API 호출 실패

**브라우저 콘솔 오류 예시:**
```
Access to XMLHttpRequest at 'http://localhost:8080/api/...'
from origin 'http://localhost:3000' has been blocked by CORS policy
```

**원인:**
- CORS_ALLOWED_ORIGINS 설정이 Frontend URL과 불일치
- 프로토콜(http/https) 불일치
- 포트 변경 후 CORS 미변경

**해결 방법:**

```bash
# 1. .env 파일 확인
cat .env | grep CORS
cat .env | grep FRONTEND_PORT

# 2. CORS 설정 수정
nano .env
```

**.env 수정:**
```env
# Frontend 접속 URL과 정확히 일치해야 함!
FRONTEND_PORT=3000
CORS_ALLOWED_ORIGINS=http://localhost:3000

# IP 주소 사용 시
CORS_ALLOWED_ORIGINS=http://192.168.1.100:3000

# 도메인 사용 시
CORS_ALLOWED_ORIGINS=https://taskflow.example.com

# 여러 Origin 허용
CORS_ALLOWED_ORIGINS=http://localhost:3000,https://taskflow.example.com
```

```bash
# 3. Backend 재시작
docker compose restart backend

# 4. 브라우저 캐시 삭제 후 재접속
```

### 7.4 권한 에러 (Linux)

**증상:**
```
permission denied while trying to connect to the Docker daemon socket
```

**원인:**
- Docker 실행 권한 없음

**해결 방법:**

```bash
# 1. Docker 그룹에 사용자 추가
sudo usermod -aG docker $USER

# 2. 재로그인 (필수!)
exit
# 다시 SSH 접속 또는 터미널 재실행

# 3. 권한 확인
groups
# docker가 포함되어 있는지 확인

# 4. Docker 테스트
docker ps

# 5. 스크립트 실행 권한
chmod +x scripts/*.sh
```

### 7.5 메모리 부족

**증상:**
- 컨테이너가 자주 죽음 (OOMKilled)
- 시스템이 느려짐

**확인 방법:**

```bash
# 1. 메모리 사용량 확인
free -h

# 2. 컨테이너 메모리 사용량
docker stats --no-stream

# 3. Docker 로그에서 OOM 확인
docker compose logs | grep -i oom
dmesg | grep -i oom
```

**해결 방법:**

```bash
# 1. 불필요한 Docker 리소스 정리
docker system prune -a
# WARNING: 모든 중지된 컨테이너, 미사용 이미지 삭제됨

# 2. 볼륨 제외하고 정리
docker system prune

# 3. 특정 정리
docker image prune    # 미사용 이미지만
docker container prune # 중지된 컨테이너만
docker volume prune   # 미사용 볼륨만 (주의!)

# 4. 스왑 메모리 추가 (Linux)
sudo fallocate -l 4G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile

# 영구 적용
echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
```

### 7.6 빌드 실패

**증상:**
```
ERROR [internal] load build context
또는
failed to solve with frontend dockerfile.v0
```

**원인:**
- 네트워크 문제 (의존성 다운로드 실패)
- 디스크 공간 부족
- Docker 캐시 문제

**해결 방법:**

```bash
# 1. 디스크 공간 확인
df -h

# 2. Docker 캐시 정리
docker builder prune -a

# 3. 캐시 없이 재빌드
docker compose build --no-cache

# 4. 빌드 로그 상세 확인
docker compose build --progress=plain

# 5. 개별 서비스 빌드
docker compose build backend
docker compose build frontend

# 6. 네트워크 문제 시 재시도
docker compose up -d --build

# 7. 완전 초기화 후 재빌드
docker compose down -v
docker system prune -a
docker compose up -d --build
```

### 7.7 Frontend 빌드 오류

**증상:**
- Frontend 컨테이너 빌드 실패
- `npm install` 또는 `npm run build` 오류

**해결 방법:**

```bash
# 1. Frontend 디렉토리 확인
ls -la frontend/

# 2. package.json 확인
cat frontend/package.json

# 3. 빌드 로그 확인
docker compose logs frontend

# 4. 로컬에서 빌드 테스트
cd frontend
npm install
npm run build
cd ..

# 5. 빌드 성공 시 Docker 재빌드
docker compose build --no-cache frontend
docker compose up -d frontend
```

### 7.8 데이터베이스 초기화 실패

**증상:**
- MySQL 컨테이너는 실행되지만 테이블이 생성되지 않음
- 초기 데이터가 없음

**해결 방법:**

```bash
# 1. 초기화 스크립트 확인
ls -la docker/mysql/init/
cat docker/mysql/init/01_schema.sql
cat docker/mysql/init/02_init_data.sql

# 2. MySQL 로그에서 초기화 과정 확인
docker compose logs mysql | grep -i "init"

# 3. 데이터베이스 완전 초기화
docker compose down -v  # 주의: 모든 데이터 삭제됨!
docker compose up -d

# 4. MySQL 접속하여 수동 확인
docker compose exec mysql mysql -u taskflow -p
```

MySQL 접속 후:
```sql
USE taskflow;
SHOW TABLES;
SELECT * FROM TB_USER;
```

### 7.9 JWT 토큰 오류

**증상:**
- 로그인 후 "Unauthorized" 오류
- 토큰 검증 실패

**해결 방법:**

```bash
# 1. JWT_SECRET 설정 확인
cat .env | grep JWT_SECRET

# 2. JWT_SECRET이 비어있거나 예시 값이면 변경
nano .env

# 3. 새 JWT_SECRET 생성
openssl rand -base64 32

# 4. Backend 재시작
docker compose restart backend

# 5. 브라우저 쿠키/로컬스토리지 삭제 후 재로그인
```

### 7.10 네트워크 문제

**증상:**
- 컨테이너 간 통신 실패
- Backend가 MySQL에 연결 못함

**해결 방법:**

```bash
# 1. 네트워크 확인
docker network ls
docker network inspect taskflow_taskflow-network

# 2. 컨테이너가 올바른 네트워크에 연결되었는지 확인
docker inspect taskflow-backend | grep -A 10 Networks
docker inspect taskflow-mysql | grep -A 10 Networks

# 3. 네트워크 재생성
docker compose down
docker network prune
docker compose up -d

# 4. 컨테이너 간 연결 테스트
docker compose exec backend ping mysql
docker compose exec backend nc -zv mysql 3306
```

---

## 8. 보안 권장사항

### 8.1 HTTPS 설정

프로덕션 환경에서는 반드시 HTTPS를 사용해야 합니다.

#### Nginx Reverse Proxy 설정

**1. Nginx 설치 (호스트 서버에)**
```bash
# Ubuntu/Debian
sudo apt update
sudo apt install nginx certbot python3-certbot-nginx

# CentOS/RHEL
sudo yum install nginx certbot python3-certbot-nginx
```

**2. Nginx 설정 파일 생성**

`/etc/nginx/sites-available/taskflow`:
```nginx
server {
    listen 80;
    server_name taskflow.example.com;

    # Let's Encrypt 인증을 위한 경로
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    # HTTPS로 리다이렉트
    location / {
        return 301 https://$server_name$request_uri;
    }
}

server {
    listen 443 ssl http2;
    server_name taskflow.example.com;

    # SSL 인증서 (certbot이 자동으로 설정)
    ssl_certificate /etc/letsencrypt/live/taskflow.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/taskflow.example.com/privkey.pem;

    # SSL 보안 설정
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;

    # 보안 헤더
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Frontend 프록시
    location / {
        proxy_pass http://localhost:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # API 프록시 (선택: Backend 직접 노출하지 않는 경우)
    location /api {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # SSE 프록시
    location /api/sse {
        proxy_pass http://localhost:8080;
        proxy_set_header Host $host;
        proxy_set_header Connection '';
        proxy_http_version 1.1;
        chunked_transfer_encoding off;
        proxy_buffering off;
        proxy_cache off;
    }
}
```

**3. 설정 활성화**
```bash
# 심볼릭 링크 생성
sudo ln -s /etc/nginx/sites-available/taskflow /etc/nginx/sites-enabled/

# 설정 테스트
sudo nginx -t

# Nginx 재시작
sudo systemctl restart nginx
```

**4. Let's Encrypt SSL 인증서 발급**
```bash
# 인증서 발급
sudo certbot --nginx -d taskflow.example.com

# 자동 갱신 설정 확인
sudo certbot renew --dry-run
```

**5. .env 파일 수정**
```env
FRONTEND_PORT=3000  # localhost에서만 접근
CORS_ALLOWED_ORIGINS=https://taskflow.example.com
COOKIE_SECURE=true
```

**6. 방화벽 설정**
```bash
# HTTP/HTTPS 포트 허용
sudo ufw allow 80/tcp
sudo ufw allow 443/tcp

# Frontend 포트는 localhost만 접근 (외부 차단)
sudo ufw deny 3000/tcp
sudo ufw deny 8080/tcp
```

### 8.2 방화벽 설정

#### Linux (UFW)
```bash
# UFW 활성화
sudo ufw enable

# SSH 포트 허용 (먼저!)
sudo ufw allow 22/tcp

# HTTPS만 허용 (Nginx 사용 시)
sudo ufw allow 443/tcp
sudo ufw allow 80/tcp  # HTTP → HTTPS 리다이렉트용

# 또는 Docker 포트 직접 허용
sudo ufw allow 3000/tcp

# 내부 서비스는 차단
sudo ufw deny 8080/tcp
sudo ufw deny 3306/tcp

# 상태 확인
sudo ufw status verbose
```

#### Linux (iptables)
```bash
# HTTPS 허용
sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT
sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT

# Frontend 허용
sudo iptables -A INPUT -p tcp --dport 3000 -j ACCEPT

# 설정 저장
sudo iptables-save > /etc/iptables/rules.v4
```

#### Windows (Windows Defender Firewall)
```powershell
# PowerShell 관리자 권한으로 실행
New-NetFirewallRule -DisplayName "TaskFlow Frontend" -Direction Inbound -Protocol TCP -LocalPort 3000 -Action Allow
New-NetFirewallRule -DisplayName "TaskFlow HTTPS" -Direction Inbound -Protocol TCP -LocalPort 443 -Action Allow
```

### 8.3 JWT_SECRET 관리

**보안 원칙:**
1. 절대 버전 관리 시스템(Git)에 포함하지 않기
2. 강력한 랜덤 키 사용 (최소 256비트)
3. 정기적으로 변경 (권장: 분기별)
4. 환경별로 다른 키 사용 (개발/스테이징/프로덕션)

**안전한 키 생성:**
```bash
# 강력한 랜덤 키 생성
openssl rand -base64 64
```

**키 변경 절차:**
```bash
# 1. 새 키 생성
NEW_KEY=$(openssl rand -base64 64)

# 2. .env 파일 백업
cp .env .env.backup

# 3. .env 파일 수정
nano .env
# JWT_SECRET=새로운키

# 4. Backend 재시작
docker compose restart backend

# 5. 모든 사용자 재로그인 필요 (기존 토큰 무효화됨)
```

**환경별 키 관리:**
```
개발: openssl rand -base64 32
스테이징: openssl rand -base64 32
프로덕션: openssl rand -base64 64  (더 강력한 키)
```

### 8.4 데이터베이스 보안

**비밀번호 정책:**
```env
# 약한 비밀번호 (개발만 사용)
MYSQL_ROOT_PASSWORD=root
MYSQL_PASSWORD=taskflow123

# 강력한 비밀번호 (프로덕션)
MYSQL_ROOT_PASSWORD=Str0ng!Root@P@ssw0rd#2024$Secure
MYSQL_PASSWORD=Pr0d!T@skfl0w#DB@2024$P@ssw0rd
```

**비밀번호 요구사항:**
- 최소 16자 이상
- 대문자, 소문자, 숫자, 특수문자 모두 포함
- 사전에 없는 단어
- 정기 변경 (권장: 분기별)

**외부 접근 차단:**
```yaml
# docker-compose.yml에서 MySQL 포트 제거
mysql:
  # ports 섹션 주석 처리 또는 삭제
  # ports:
  #   - "${MYSQL_PORT:-3306}:3306"
```

**백업 파일 암호화:**
```bash
# 백업 생성 및 암호화
docker compose exec mysql mysqldump -u taskflow -p taskflow | \
  gpg --symmetric --cipher-algo AES256 > backup-$(date +%Y%m%d).sql.gpg

# 복호화
gpg --decrypt backup-20241224.sql.gpg > backup-20241224.sql
```

### 8.5 로그 보안

**민감 정보 제거:**
- 로그에 비밀번호, 토큰, 개인정보 출력 금지
- Backend 로깅 설정 검토

**로그 접근 제한:**
```bash
# 로그 파일 권한 설정
chmod 600 backups/*.log
chmod 700 backups/

# 소유자만 읽기/쓰기 가능
```

### 8.6 컨테이너 보안

**최소 권한 원칙:**
```yaml
# docker-compose.yml에 보안 설정 추가
services:
  backend:
    # ... 기존 설정 ...
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
```

**정기 업데이트:**
```bash
# Base 이미지 업데이트
docker compose pull

# 재빌드 및 재시작
docker compose up -d --build
```

### 8.7 모니터링 및 감사

**보안 이벤트 모니터링:**
- 로그인 실패 횟수 모니터링
- 비정상적인 API 호출 감지
- 리소스 사용량 모니터링

**정기 점검 체크리스트:**
- [ ] JWT_SECRET 변경 (분기별)
- [ ] 데이터베이스 비밀번호 변경 (분기별)
- [ ] SSL 인증서 갱신 확인 (Let's Encrypt: 자동)
- [ ] Docker 이미지 업데이트 (월별)
- [ ] 백업 정상 동작 확인 (주별)
- [ ] 로그 검토 (주별)
- [ ] 방화벽 규칙 검토 (월별)

---

## 부록

### A. 환경변수 전체 목록

| 변수명 | 필수 | 기본값 | 설명 |
|--------|:----:|--------|------|
| **데이터베이스** |
| MYSQL_ROOT_PASSWORD | O | root | MySQL root 비밀번호 |
| MYSQL_DATABASE | O | taskflow | 데이터베이스명 |
| MYSQL_USER | O | taskflow | DB 사용자명 |
| MYSQL_PASSWORD | O | taskflow123 | DB 사용자 비밀번호 |
| **인증** |
| JWT_SECRET | O | (설정 필요) | JWT 서명 키 (Base64, 256bit+) |
| **포트** |
| MYSQL_PORT | - | 3306 | MySQL 외부 포트 |
| BACKEND_PORT | - | 8080 | Backend 외부 포트 |
| FRONTEND_PORT | - | 3000 | Frontend 외부 포트 |
| **보안** |
| CORS_ALLOWED_ORIGINS | - | http://localhost:3000 | CORS 허용 Origin |
| COOKIE_SECURE | - | false | HTTPS 전용 쿠키 (true/false) |
| **시스템** |
| TZ | - | Asia/Seoul | 시간대 |

### B. Docker Compose 명령어 참고

| 명령어 | 설명 |
|--------|------|
| `docker compose up -d` | 백그라운드로 시작 |
| `docker compose up -d --build` | 재빌드하여 시작 |
| `docker compose down` | 중지 및 제거 |
| `docker compose down -v` | 중지 및 볼륨까지 제거 |
| `docker compose ps` | 컨테이너 상태 확인 |
| `docker compose logs -f` | 로그 실시간 확인 |
| `docker compose restart` | 재시작 |
| `docker compose stop` | 중지 (제거 안함) |
| `docker compose start` | 시작 |
| `docker compose exec <service> <command>` | 컨테이너 내 명령 실행 |

### C. 유용한 스크립트

#### 상태 확인 스크립트

`scripts/status.sh`:
```bash
#!/bin/bash

echo "=== TaskFlow 상태 ==="
echo ""

echo "컨테이너 상태:"
docker compose ps
echo ""

echo "리소스 사용량:"
docker stats --no-stream
echo ""

echo "디스크 사용량:"
docker system df
echo ""

echo "Frontend 접속: http://localhost:3000"
echo "Backend API: http://localhost:8080"
```

#### 전체 로그 저장 스크립트

`scripts/save-logs.sh`:
```bash
#!/bin/bash

LOG_DIR="logs"
DATE=$(date +%Y%m%d-%H%M%S)

mkdir -p "$LOG_DIR"

docker compose logs > "$LOG_DIR/all-$DATE.log"
docker compose logs backend > "$LOG_DIR/backend-$DATE.log"
docker compose logs frontend > "$LOG_DIR/frontend-$DATE.log"
docker compose logs mysql > "$LOG_DIR/mysql-$DATE.log"

echo "로그 저장 완료: $LOG_DIR/"
```

### D. 문제 발생 시 체크리스트

1. [ ] 컨테이너 상태 확인: `docker compose ps`
2. [ ] 로그 확인: `docker compose logs -f`
3. [ ] 환경변수 확인: `cat .env`
4. [ ] 포트 충돌 확인: `lsof -i :3000`
5. [ ] 디스크 공간 확인: `df -h`
6. [ ] 메모리 확인: `free -h`
7. [ ] Docker 버전 확인: `docker --version`
8. [ ] 네트워크 확인: `docker network ls`

---

## 문서 정보

- **문서 버전**: 2.0
- **최종 수정일**: 2024-12-24
- **작성자**: TaskFlow 개발팀
- **문서 위치**: /mnt/d/SNS_Proj/Taskflow/docs/2.0/03_배포_가이드.md
